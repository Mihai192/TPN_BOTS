<p>Corina are un text format din mai multe cuvinte separate între ele printr-un spațiu, pentru care trebuie să utilizeze cuvintele aflate pe poziţii consecutive. Se știe  că pentru  două cuvinte pe care le vom numi <code>x</code> și <code>y</code>:</p>

<ul>
	<li>cuvântul <code>x=x[0]x[1]...x[n-1]</code>  este prefix al cuvântului <code>y=y[0]y[1]...y[m-1]</code>, dacă <code>x[0]=y[0]</code>, <code>x[1]= y[1]</code>,…, <code>x[n-1]=y[n-1]</code></li>
	<li>cuvântul <code>x=x[0]x[1]...x[n-1]</code> este sufix al cuvântului <code>y=y[0]y[1]...y[m-1]</code>, dacă există un indice <code>i</code>, (<code>0≤ i≤ m-1</code>),  astfel încât <code>x[0]=y[i]</code>, <code>x[1]= y[i+1]</code>,…, <code>x[n-1]= y[m-1]</code>.</li>
</ul>

<h1>Cerința</h1>

<p>Scrieţi un program care determină&nbsp;pentru un text dat, format din mai multe cuvinte separate între ele printr-un spațiu, două cerințe:</p>

<ul>
	<li>cerința 1: câte perechi de cuvinte, notate <code>x</code> și <code>y</code>, aflate pe poziții consecutive în text au proprietatea: <code>x</code> este sufix al lui <code>y</code>  sau <code>x</code> este prefix al lui <code>y</code>.</li>
	<li>cerința 2 : care este perechea de cuvinte, aflate pe poziții consecutive în text, care conține cele mai multe caractere.</li>
</ul>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>cuvinte6.in</code> conține pe prima linie un text, format din mai multe cuvinte separate între ele printr-un spațiu și pe a doua linie conține un număr natural <code>t</code>, care reprezintă cerința (dacă <code>t=1</code> se va rezolva cerința 1, dacă <code>t=2</code> se va rezolva cerința 2).</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>cuvinte6.out</code> va conține pe prima linie, pentru cerința 1, un număr natural, ce reprezintă numărul de perechi de cuvinte, notate x și y, aflate pe poziții consecutive în text care au proprietatea: x este sufix al lui y  sau x este prefix al lui y.</p>

<p>Fișierul de ieșire <code>cuvinte6.out</code> va conține pe prima linie, pentru cerința 2 două cuvinte, separate printr-un spațiu, ce reprezintă perechea de cuvinte, aflate pe poziții consecutive în text, care conține cele mai multe caractere.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li>Textul dat conține cel mult 500 de caractere</li>
	<li>Fiecare cuvânt din text este format numai din litere mici ale alfabetului englez</li>
	<li>Fiecare cuvânt din text  conține cel puțin o literă și cel mult 20 de litere</li>
	<li>Pentru cerința 2, dacă textul dat are mai multe perechi de cuvinte, aflate pe poziții consecutive în text, care conțin cele mai multe caractere, se va afișa prima pereche din text, cu această proprietate.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>cuvinte6.in</code></p>

<pre contenteditable="true" editable="true">calcul calcule are care parcare corecte corectie
1</pre>

<p><code>cuvinte6.out</code></p>

<pre contenteditable="true" editable="true">3</pre>

<h3>Explicație</h3>

<p>Cerința 1:<br>
Textul conține <code>3</code> perechi de cuvinte : <code>(calcul,calcule)</code>, <code>(are,care)</code>, <code>(care,parcare)</code>.</p>


<h1>Exemplul 2</h1>

<p><code>cuvinte6.in</code></p>

<pre contenteditable="true" editable="true">calcul calcule are care parcare corecte corectie
2</pre>

<p><code>cuvinte6.out</code></p>

<pre contenteditable="true" editable="true">corecte corectie</pre>

<h3>Explicație</h3>

<p>Cerința 2: Perechea de cuvinte <code>corecte corectie</code> conține <code>14</code> caractere și reprezintă perechea cu cele mai multe caractere din text.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <cstring>
using namespace std;

ifstream cin("cuvinte6.in");
ofstream cout("cuvinte6.out");

int prefix(char a[] , char b[])
{
    int na = strlen(a);
    for(int i = 0 ; i < na ; i++)
        if(a[i] != b[i]) return 0;
    return 1;
}

int sufix(char a[] , char b[])
{
    int na = strlen(a) , nb = strlen(b);
    for(int i = na - 1 , j = nb - 1 ; i >= 0 ; i-- , j--)
        if(a[i] != b[j]) return 0;
    return 1;
}

int main()
{
    char s[501] , *p , a[256][20];
    int cer , cnt = 0 , cate = 0;
    cin.getline(s , 501);
    cin >> cer;
    p = strtok(s , " ");
    while(p != 0)
    {
        strcpy(a[++cnt] , p);
        p = strtok(NULL , " ");
    }
    if(cer == 1)
    {
        for(int i = 1 ; i < cnt ; i++)
            if(prefix(a[i], a[i + 1]) || sufix(a[i] , a[i + 1])) cate++;
            cout << cate;
    }
    else
    {
        char cuv1[256] , cuv2[256];
        int maxi = 0;
        for(int i = 1 ; i < cnt ; i++)
        {
            if(strlen(a[i]) + strlen(a[i + 1]) > maxi)
            {
                maxi = strlen(a[i]) + strlen(a[i + 1]);
                strcpy(cuv1 , a[i]);
                strcpy(cuv2 , a[i + 1]);
            }
        }
        cout << cuv1 << " " << cuv2;
    }
    return 0;
}</pre>
