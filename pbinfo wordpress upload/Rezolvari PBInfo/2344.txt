<h1>Enunț</h1>

<p><code>R.</code> a descoperit de curând tastatura <code>DVORAK</code> și s-a decis că poate scrie mult mai rapid și mai corect cod folosind această tastatură decât folosind tastatura <code>QWERTY</code>.  Plictisindu-se, <code>R.</code> a creat, pentru a onora tastatura lui preferată, <strong>transformarea <code>dvorak</code></strong>, care se realizează prin înlocuirea fiecărei litere dintr-un șir de caractere cu corespondența acesteia dintr-o permutare dată a alfabetului englez.  De exemplu, cuvântul <code>informatica</code> poate să devină, printr-o transformare dvorak, <code>cburpmaycja</code>.</p>

<p><code>H.</code>, profitor din fire, a decis să intre pe calculatorul lui <code>R.</code> și să îi fure sursele valoroase de la problemele “rupere” pe care le-a rezolvat. </p>

<p>Dar <code>R.</code> şi-a securizat calculatorul cu o parolă (constând într-o succesiune de litere mici ale alfabetului englez). Din când în când, <code>R.</code> își modifică o parte din parolă efectuând următoarea operație: alege două poziții în parolă <code>S</code><sub><code>i</code></sub> (capăt stânga) si <code>D</code><sub><code>i</code></sub> (capăt dreapta) apoi aplică transformarea dvorak asupra secvenței formată din caracterele situate în parolă pe poziții din intervalul <code>[S</code><sub><code>i</code></sub>, <code>D</code><sub><code>i</code></sub><code>]</code>. Această operație este de tipul <code>1</code> și este codificată prin: <code>1 S</code><sub><code>i</code></sub> <code>D</code><sub><code>i</code></sub>.  </p>

<p>Acum <code>H.</code> are nevoie de ajutorul vostru ca să afle parola şi să furați împreună  toate sursele ca sa fiți primii la statistici pe Varena). Din când în când, el vă va da câte un sir de caractere nevid (<code>SIR</code>) și vă va întreba dacă acest șir se regăsește ca subsecvență în parola lui <code>R</code>. Această operație este de tipul <code>2</code> și este codificată prin: <code>2 SIR</code>  </p>

<h1>Cerința</h1>

<p>Cunoscându-se permutarea dată, parola lui <code>R.</code> precum și o succesiune de <code>Q</code> operații de tipul <code>1</code> sau <code>2</code>, găsiți răspunsurile la întrebările toate lui <code>H.</code> </p>

<h1>Date de intrare</h1>

<p>Pe prima linie a fișierului <code>dvorak.in</code> se va afla numărul natural <code>Q</code> reprezentând numărul de operații din succesiunea dată. <br>
Pe cea de-a doua linie se va afla <code>permutarea dată</code> pentru <code>transformarea dvorak</code>.<br>
Pe cea de-a treia linie se va afla un sir de caractere litere mici, reprezentând <code>parola inițială</code> a lui <code>R.</code> <br>
Pe fiecare dintre următoarele <code>Q</code> linii se află câte o operație de tip <code>1</code> sau <code>2</code>, codificate ca în enunț. </p>

<h1>Date de ieșire</h1>

<p>Pe fiecare linie a fișierului <code>dvorak.out</code> se va afla răspunsul pentru fiecare dintre intrebările lui <code>H.</code>, în ordinea în care apar în fișierul de intrare: răspundeti cu <code>Da</code> dacă șirul se regăsește ca subsecvență în parola și <code>Nu</code> altfel.  </p>

<h1>Restricții și precizări</h1>

<p>• <code>1 ≤ Q ≤ 500</code><br>
• Fiecare al <code>i</code>-lea element al permutării date reprezintă litera în care se transformă cel de-al <code>i</code>-lea caracter din alfabetul englez într-o transformare dvorak<br>
• Se garantează că fiecare literă din permutarea dată apare o singură dată, iar permutarea are fix <code>26</code> de caractere<br>
• Parola este un șir de cel mult <code>500</code> de litere mici ale alfabetului englez. <br>
• Pozițiile caracterelor din parolă sunt numerotate incepând de la <code>1</code><br>
• <code>1 ≤ S</code><sub><code>i</code></sub><code> ≤  D</code><sub><code>i</code></sub><code> ≤ </code>lungimea parolei  <br>
• Intervalele <code>[S</code><sub><code>i</code></sub>, <code>D</code><sub><code>i</code></sub><code>]</code> corespunzătoare operației <code>1</code> se pot suprapune <br>
• Șirul <code>SIR</code> pentru operația <code>2</code> are cel mult <code>500</code> de caractere</p>

<br><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- link-unit -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:15px" data-ad-client="ca-pub-7152921241438800" data-ad-slot="6421896419" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0;width:728px;height:15px;" sandbox="allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="728" height="15" frameborder="0" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-7152921241438800&amp;output=html&amp;h=15&amp;slotname=6421896419&amp;adk=1130877403&amp;adf=1958414068&amp;w=728&amp;lmt=1595356912&amp;psa=1&amp;guci=1.2.0.0.2.2.0.0&amp;url=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F2344%2Fdvorak&amp;flash=0&amp;wgl=1&amp;dt=1595356912496&amp;bpp=5&amp;bdt=235&amp;idt=183&amp;shv=r20200716&amp;cbv=r20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;prev_fmts=336x280%2C0x0&amp;nras=1&amp;correlator=5736759740568&amp;frm=20&amp;pv=1&amp;ga_vid=704522989.1595356494&amp;ga_sid=1595356913&amp;ga_hid=1594792955&amp;ga_fc=0&amp;iag=0&amp;icsg=17380323360767&amp;dssz=47&amp;mdo=0&amp;mso=0&amp;u_tz=180&amp;u_his=50&amp;u_java=0&amp;u_h=900&amp;u_w=1440&amp;u_ah=816&amp;u_aw=1440&amp;u_cd=30&amp;u_nplug=3&amp;u_nmime=4&amp;adx=41&amp;ady=1633&amp;biw=1200&amp;bih=649&amp;scr_x=0&amp;scr_y=0&amp;eid=21066623&amp;oid=3&amp;pvsid=2842825650445396&amp;pem=564&amp;ref=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F863%2Fparole&amp;rx=0&amp;eae=0&amp;fc=896&amp;brdim=22%2C45%2C22%2C45%2C1440%2C23%2C1200%2C772%2C1200%2C649&amp;vis=1&amp;rsz=%7Co%7CeEbr%7C&amp;abl=NS&amp;pfx=0&amp;fu=8192&amp;bc=31&amp;ifi=2&amp;uci=a!2&amp;btvi=1&amp;fsb=1&amp;xpc=ubnLaKojVq&amp;p=https%3A//www.pbinfo.ro&amp;dtd=189" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" data-google-container-id="a!2" data-load-complete="true" data-google-query-id="CJKyzND_3uoCFdH_sgod1_kIFA"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1>Exemplu</h1>

<p><code>dvorak.in</code></p>

<pre contenteditable="true" editable="true">6
ifynmlbkpduogahqzsjxcervwt
olimpiadadeinformatica
1 1 6
2 info
2 olimpiada
1 8 15
1 9 14
2 olimpiadadeinformaticaecool5</pre>

<p><code>dvorak.out</code></p>

<pre contenteditable="true" editable="true">Da
Nu
Nu</pre>

<h3>Explicație</h3>

<p>După prima operație, parola se transformă în <code>hopgqpadadeinformatica</code><br>
La a doua operație se răspunde cu <code>Da</code>. <br>
La a treia operație se răspunde cu <code>Nu</code>.<br>
După a patra operație, parola se transformă în <code>hopgqpaninmpalhrmatica</code>.<br>
După a cincea operație, parola se transformă în <code>hopgqpanpagqiohrmatica</code>.<br>
La a șasea operație se răspunde cu <code>Nu</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <cstring>
using namespace std;

ifstream cin("dvorak.in");
ofstream cout("dvorak.out");

bool verif(int i , char s[501] , char sir[501])
{
    for(int j = 0 ; j < strlen(s) &amp;&amp; sir[i] ; ++j , ++i)
        if(s[j]!=sir[i])
            return 0;
    return 1;
}

bool inclus(char s[501] , char sir[501])
{
    if(strlen(s) > strlen(sir))
        return 0;
    bool ok = false;
    for(int i = 0 ; i <= strlen(sir)-strlen(s) ; ++i)
        if(verif(i , s , sir))
            ok=true;
    return ok;
}

int main()
{
    int q;
    cin >> q;
    char perm[27];
    cin >> perm;
    char sir[501];
    cin >> sir;
    char s[501];
    for(int i = 1 ; i <= q ; ++i)
    {
        int x;
        cin >> x;
        if(x==1)
        {
            int st , dr;
            cin >> st >> dr;
            for(int j = st - 1 ; j < dr ; ++j)
                sir[j] = perm[ sir[j] - 'a' ];
        }
        else
        {
            cin >> s;
            if(inclus(s , sir))
                cout << "Da" << '\n';
            else
                cout << "Nu" << '\n';
        }
    }
    return 0;
}</pre>
