<p>Forța unui număr natural nenul <code>X</code> este egală cu numărul de divizori pozitivi ai lui <code>X</code>. De exemplu, numărul <code>X = 10</code> are forţa <code>4</code>, deoarece <code>10</code> are <code>4</code> divizori, mulțimea divizorilor fiind <code>D</code><sub><code>10</code></sub><code> = {1,2,5,10}</code>.</p>

<h1>Cerința</h1>

<p>Scrieţi un program care, cunoscând un șir de <code>n</code> numere naturale nenule, rezolvă următoarele cerințe:</p>

<p>1. determină cel mai mic număr din șir care are forța maximă;<br>
2. determină lungimea maximă a unei secvențe formată din numere cu aceeași forţă ce poate fi obținută prin rearanjarea convenabilă a elementelor din șir.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>forta.in</code> conține pe prima linie numărul <code>c</code>, care reprezintă cerința de rezolvat (<code>1</code> sau <code>2</code>), pe a doua linie un număr natural <code>n</code>, iar pe următoarea linie <code>n</code> numere naturale separate prin câte un spațiu, reprezentând elementele șirului.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>forta.out</code> va conține o singură linie pe care va fi scris un număr natural reprezentând răspunsul la cerința <code>c</code>.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ n ≤ 100000</code></li>
	<li><code>1 ≤</code> numerele din șir ≤ <code>2000000000</code></li>
	<li>O secvență este constituită dintr-un singur număr sau mai multe numere aflate pe poziții consecutive în șir. Lungimea unei secvențe este egală cu numărul de valori care o compun.</li>
	<li>Pentru prima cerință se acordă 50 de puncte, iar pentru cea de a doua cerință se acordă 40 de puncte.</li>
	<li>Pentru teste valorând 30 de puncte <code>1 ≤ n ≤ 10000</code></li>
	<li>În concurs problema s-au acordat 10 puncte din oficiu. Pe site se acordă 10 puncte pentru exemple.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>forta.in</code></p>

<pre contenteditable="true" editable="true">1
6
17 243 10 32 25 13</pre>

<p><code>forta.out</code></p>

<pre contenteditable="true" editable="true">32</pre>

<h3>Explicație</h3>

<p>Cerința este <code>1</code>. <code>D</code><sub><code>17</code></sub><code>={1,17}</code>, <code>D</code><sub><code>243</code></sub><code>={1,3,9,27,81,243}</code>, <code>D</code><sub><code>10</code></sub><code>={1,2,5,10}</code>, <code>D</code><sub><code>32</code></sub><code>={1,2,4,8,16,32}</code>, <code>D</code><sub><code>25</code></sub><code>={1,5,25}</code>, <code>D</code><sub><code>13</code></sub><code>={1,13}</code>. Deci cea mai mare forță este <code>6</code>, iar numărul minim cu această forță este <code>32</code>.</p>

<h1>Exemplul 2</h1>

<p><code>forta.in</code></p>

<pre contenteditable="true" editable="true">2
8
121 10 14 25 49 9 25 15</pre>

<p><code>forta.out</code></p>

<pre contenteditable="true" editable="true">5</pre>

<h3>Explicație</h3>

<p>Cerința este <code>2</code>. O rearanjare a șirului ar putea fi <code>(10 14 15)(121 25 49 9 25)</code> astfel încât putem obține o secvență de lungime <code>3</code> de numere de forță <code>4</code> și o secvență de lungime <code>5</code> de numere de forță <code>3</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <algorithm>
using namespace std;

ifstream cin("forta.in");
ofstream cout("forta.out");

long long n , cer , maxi , vali , cnt;
int E[100001] , P[8001];

struct poz
{
    int val , f;
}a[100001];


void ciur()
{
    long long maxi = 100001;
    for(int i = 2 ; i <= maxi ; i++) E[i] = 1;
    for(int i = 2 ; i * i <= maxi ; i++)
        if(E[i] == 1)
            for(int j = i * i; j <= maxi ; j += i) E[j] = 0;

    for(int i = 2 ; i <= maxi ; i++)
        if(E[i] == 1) P[++cnt] = i;
}

long long nrdiv(int n)
{
    long long d = 1 , prod = 1;
    while(n > 1 &amp;&amp; P[d] * P[d] <= n)
    {
        int p = 0;
        while(n % P[d] == 0) p++ , n /= P[d];
        if(p) prod *= (p + 1);
        d++;
    }
    if(n != 1)prod *= 2;
    return prod;
}

int comp(poz a , poz b)
{
    if(a.f < b.f) return 1;
    else if(a.f == b.f &amp;&amp; a.val < b.val) return 1;
    else return 0;
}

int main()
{
    cin >> cer >> n;
    ciur();
    for(int i = 1 ; i <= n ; i++)
    {
        cin >> a[i].val;
        a[i].f = nrdiv(a[i].val);
        if(a[i].f > maxi) maxi = a[i].f , vali = a[i].val;
        else if(a[i].f == maxi)
            if(a[i].val < vali) vali = a[i].val;
    }
    if(cer == 1) cout << vali;
    else
    {
        sort(a + 1 , a + n + 1 , comp);
        if(n > 1)
        {
            maxi = -10000 , cnt = 0;
            for(int i = 2 ; i <= n ; i++)
            {
                //cout << cnt << '\n';
                if(a[i].f == a[i - 1].f) cnt++;
                else
                {
                    if(cnt > maxi) maxi = cnt;
                    cnt = 0;
                }
            }
            if(cnt > 0)
                if(cnt > maxi) maxi = cnt;
            cout << maxi + 1;
        }
        else cout << 1;
    }

}</pre>
