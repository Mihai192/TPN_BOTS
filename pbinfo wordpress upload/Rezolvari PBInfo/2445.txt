<p>Într-un laborator cibernetic se fac experimente cu roboţi. Pe o bandă de lucru se află aşezate unul lângă altul, <code>N</code> cuburi galbene şi albastre, numeroate în ordine cu valori de la <code>1</code> la <code>N</code>. Pentru fiecare cub se cunoaşte latura acestuia, exprimată în centimetri, şi culoarea, codificată prin simbolul <code>g</code> (pentru galben) sau <code>a</code> (pentru albastru). Un robot inteligent este programat să construiască turnuri prin aşezarea cuburilor unul peste altul. El se află în faţa benzii de lucru, analizează fiecare cub în ordine, de la primul la ultimul, şi procedează astfel :</p>

<p><img alt="" src="/resurse/16a4b0/turnuri1_1.jpg"></p>

<ul>
	<li>dacă este primul cub, îl lasă la locul lui pe bandă;</li>
	<li>aşează cubul numerotat cu <code>K</code> peste cubul numerotat cu <code>K-1</code> doar dacă el are culoarea diferită şi latura mai mică decât cubul <code>K-1</code>. Această operaţie se efectuează în cazul în care cubul <code>K-1</code> se află deja într-un turn constuit anterior sau dacă el a rămas în poziția inițială. În cazul în care cubul <code>K</code> nu poate fi aşezat peste cubul <code>K-1</code>, el rămâne la locul lui.</li>
</ul>

<h1>Cerința</h1>

<p>Ştiind că un turn poate fi format din cel puţin un cub, scrieţi un program care să determine:<br>
1. numărul final <code>T</code> al turnurilor de pe bandă şi <code>H</code>, înălţimea celui mai înalt turn care se poate forma, exprimată în centimetri;<br>
2. cel mai mare număr de cuburi <code>Nmax</code> ce pot forma un turn, dacă cele <code>N</code> cuburi ar putea fi rearanjate inițial pe bandă, unul lângă altul.</p>

<h1>Date de intrare</h1>

<p>Fişierul <code>turnuri1.in</code> conţine:<br>
- pe prima linie un număr natural <code>C</code> care reprezintă numărul cerinţei şi poate fi <code>1</code> sau <code>2</code>.<br>
- pe cea de-a doua linie un număr natural <code>N</code> ce reprezintă numărul cuburilor de pe bandă;<br>
- pe fiecare dintre următoarele <code>N</code> linii, câte un număr natural care reprezintă latura unui cub, urmat de un spaţiu şi simbolul <code>g</code> sau <code>a</code>, pentru codificarea culorii cubului.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>turnuri1.out</code> va conţine pentru cerința 1 (<code>C=1</code>) pe prima linie două valori, separate printr-un spațiu, ce reprezintă <code>T</code> și <code>H</code>. Pentru cerința 2 (<code>C=2</code>) fișierul va conține pe prima linie numărul <code>Nmax</code>.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ N ≤ 10 000</code> şi <code>1≤ latura unui cub ≤ 500 000</code>;</li>
	<li>nu există două cuburi cu laturi egale;</li>
	<li>Pentru rezolvarea corectă a primei cerințe se acordă <code>30</code> de puncte, pentru rezolvarea corectă a celei de-a doua cerințe se acordă <code>60</code> de puncte.</li>
	<li>În concurs s-au acordat <code>10</code> din oficiu. Aici se acordă <code>10</code> puncte pentru exemplele din enunț.</li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>turnuri1.in</code></p>

<pre contenteditable="true" editable="true">1
6
18 a
13 g
15 a
10 a
8 g
2 a</pre>

<p><code>turnuri1.out</code></p>

<pre contenteditable="true" editable="true">3 31</pre>

<h3>Explicație</h3>

<p>Se va rezolva cerința 1.<br>
Al doilea cub se aşează peste primul şi formează un turn cu înălţimea de <code>31</code> de centimetri. Al treilea cub formează singur un turn cu înălţimea <code>15</code> centimetri. Ultimele trei cuburi formează un turn cu înălţimea <code>20</code> de centimetri. Numărul turnurilor este <code>3</code>. Înălţimea celui mai înalt turn este de <code>31</code> de centimetri.</p>

<h1>Exemplul 2:</h1>

<p><code>turnuri1.in</code></p>

<pre contenteditable="true" editable="true">2
6
18 a
13 g
15 a
10 a
8 g
2 a</pre>

<p><code>turnuri1.out</code></p>

<pre contenteditable="true" editable="true">5</pre>

<h3>Explicație</h3>

<p>Se va rezolva cerința 2. O posibilă rearanjare a cuburilor ar fi următoarea:</p>

<p><img alt="" src="/resurse/16a4b0/turnuri1_2.jpg"></p>

<p>Primele <code>5</code> cuburi formează un turn.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <algorithm>
using namespace std;

ifstream fin("turnuri1.in");
ofstream fout("turnuri1.out");

int C,n,n1,n2;
long long int nr_turnuri , max_turn;
int v1[10003] , v2[10003] , v3;

void citire()
{   
    int l1,l2,i;
    long long h_turn;
    char cul1,cul2;

    fin>>C>>n;
    fin>>l1>>cul1;
    nr_turnuri=1;h_turn=l1;
    if(cul1=='g') v1[++n1]=l1;
       else v2[++n2]=l1;
    for(i=1; i<=n-1; i++)
    {
        fin>>l2>>cul2;
        if(cul2=='g') v1[++n1]=l2;
           else v2[++n2]=l2;

        if(l2<l1 &amp;&amp; cul2!=cul1)
            {h_turn=h_turn+l2;}
        else
            {nr_turnuri++;h_turn=l2;}
        if (h_turn>max_turn) max_turn=h_turn;
        l1=l2;cul1=cul2;
    }
}

bool cmp( int a, int b)
{
    return (a>b);
}

int main()
{
    int i,j,k,p;
    citire();
    if (C==1)
        fout<<nr_turnuri<<' '<<max_turn<<'\n';
    else
    {
        sort(v1+1,v1+1+n1,cmp);
        sort(v2+1,v2+1+n2,cmp);
        v1[n1+1]=500003;
        v2[n2+1]=500002;
        i=1;j=1;k=0;
        if (v1[i]>v2[j])
        {
            ++k;v3=v1[i++];p=1;
        }
        else
        {
            ++k;v3=v2[j++];p=-1;
        }
        while(i<=n1&amp;&amp;j<=n2)
        {
            if(p==1)
            {
                while(j<=n2 &amp;&amp; v2[j]>=v3)
                    j++;
                if (j<=n2)
                {++k; v3=v2[j++];p=-p;}
            }
            else
            {
                while(i<=n1 &amp;&amp; v1[i]>=v3)
                    i++;
                if(i<=n1)
                {++k;v3=v1[i++];p=-p;}
            }
        }
       if(p==-1)
        for(i;i<=n1;i++)
            if (v1[i]<v3) {++k;v3=v1[i];break;}
       if(p==1)
            for(j;j<=n2;j++)
            if (v2[j]<v3) {++k;v3=v2[j];break;}
       fout<<k<<'\n';
    }
    return 0;
}</pre>
