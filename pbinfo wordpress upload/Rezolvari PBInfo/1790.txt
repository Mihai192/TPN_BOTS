<p>Cercetări recente au scos la iveală un vechi document scris într-un dialect ciudat denumit <em>masaretu</em>. Textul conţinut de acest document este format din cuvinte iar între două cuvinte există cel puţin un spaţiu.</p>

<p>Despre acest dialect se cunosc câteva caracteristici:</p>

<ul>
	<li>scrierile din acest dialect folosesc literele mici ale alfabetului englez;</li>
	<li>toate cuvintele dialectului au exact opt litere;</li>
	<li>cuvintele dialectului sunt formate din silabe. Fiecare silabă are două litere dintre care una este o vocală (adică una dintre literele <code>a e i o u</code>) iar cealaltă o consoană. Rezultă că fiecare cuvânt are patru silabe.</li>
</ul>

<p>Din păcate documentul descoperit este deteriorat: din unele cuvinte au dispărut una sau mai multe litere. Astfel în document apar grupuri formate din mai puţin de opt litere care nu mai reprezintă cuvinte ale vocabularului dialectului masaretu.</p>

<h1>Cerința</h1>

<p>Să se scrie un program care determină:</p>

<p>1) câte cuvinte corecte sunt în documentul recent descoperit.<br>
2) silabele care apar cel mai des în cuvintele corecte din document.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>masaretu.in</code> conține:</p>

<ul>
	<li>pe prima linie un număr natural <code>V</code> care poate avea valoarea <code>1</code> sau valoarea <code>2</code>.</li>
	<li>pe a doua linie un şir de cel mult <code>1000000</code> de caractere, care reprezintă textul documentului.</li>
</ul>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>masaretu.out</code> va avea o singură linie cu următorul conţinut:</p>

<ul>
	<li>dacă <code>V = 1</code>, atunci pe această linie se va scrie un număr care reprezintă răspunsul la prima cerință a problemei – adică numărul de cuvinte corecte din textul dat.</li>
	<li>dacă <code>V = 2</code>, atunci pe prima linie a fişierului de ieşire se vor scrie <strong>în ordine alfabetică</strong> toate silabele care apar cel mai des în cuvintele corecte ale textului dat.</li>
</ul>

<h1>Restricții și precizări</h1>

<ul>
	<li>textul de pe a doua linie din fişier începe şi se termină cu o literă;</li>
	<li>în textul dat există cel puţin un cuvânt corect al dialectului <em>masaretu</em>;</li>
	<li>20% din teste vor avea valoarea <code>V=1</code>, iar 80% din teste vor avea valoarea <code>V=2</code>.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>masaretu.in</code></p>

<pre contenteditable="true" editable="true">1
masaretu mare dialectu andiculu tare</pre>

<p><code>masaretu.out</code></p>

<pre contenteditable="true" editable="true">3</pre>

<h3>Explicație</h3>

<p><code>V=1</code>, deci se rezolvă <span class="caps">NUMAI</span> prima cerinţă. </p>

<p>Sunt trei cuvinte corecte: <code>masaretu dialectu andiculu</code></p>

<h1>Exemplul 2</h1>

<p><code>masaretu.in</code></p>

<pre contenteditable="true" editable="true">2
masaretu mare dialectu andiculu tare</pre>

<p><code>masaretu.out</code></p>

<pre contenteditable="true" editable="true">di tu</pre>

<h3>Explicație</h3>

<p><code>V=2</code>, deci se rezolvă <span class="caps">NUMAI</span> a doua cerinţă. </p>

<p>Silabele care apar cel mai des in cele trei cuvinte corecte sunt <code>di</code> si <code>tu</code>. Ambele apar de două ori.</p>

<p>Nu se numără silabele care apar în cuvintele incorecte! Silaba <code>re</code> se va număra doar o dată în cuvântul corect <code>masaretu</code> şi nu se va număra în cuvintele incomplete <code>mare</code> şi <code>tare</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;

ifstream cin("masaretu.in");
ofstream cout("masaretu.out");

char s[1000001];
int f[10000];

int main()
{
    int c;
    cin >> c;
    cin.getline(s , 10000);
    cin.getline(s , 1000001);
        int i = 0;
        int cnt=0 , conto=0;
        while(s[i]!='\0')
        {
            if(s[i]==' ')
            {
                if(cnt==8)
                    conto++;
                cnt=0;
            }
            else
            {
                cnt++;

            }
            i++;
        }
        if(cnt==8)
            conto++;
    if(c==1)
        cout << conto;
    s[i]=' ' , s[i+1]='\0';
         i = 0; 
    int j = 0;
         cnt=0 , conto=0;
        while(s[i]!='\0')
        {
            if(s[i]==' ')
            {
                if(cnt==8)
                {
                    conto++;
                    int cn=0;
                    int nr=0;
                    while(j < i)
                    {
                        nr = nr * 100 + ((int)s[j]-96);
                        cn++;
                        if(cn == 2)
                        {
                            f[nr]++;
                            cn=0 , nr = 0;
                        }
                        j++;
                    }
                }
                cnt=0;
                j=i+1;
            }
            else
            {
                cnt++;
            }
            i++;
        }
        int fmax = 0 , nr ;
        for(int i = 100 ; i < 3000 ; ++i)
        {
            if(f[i] > fmax)
                fmax=f[i];
        }
    if(c==2)
        for(int i = 100 ; i < 3000 ; ++i)
            if(f[i]==fmax)
                cout << ((char)(i/100 + 96)) << ((char)(i % 100 + 96)) << ' ';
    return 0;
}</pre>
