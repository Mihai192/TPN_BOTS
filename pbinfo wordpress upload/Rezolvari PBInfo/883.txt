<h1>Cerința</h1>

<p>Se consideră harta unei suprafețe deșertice, dată sub forma unei matrice cu <code>n</code> linii și <code>m</code> coloane, formată din <code>n*m</code> zone. Fiecare zonă poate fi accesibilă sau inaccesibilă. Dintr-o zonă accesibilă se poate trece în altă zonă accesibilă învecinată cu prima pe linie sau pe coloană.</p>

<p>Un călător dorește să traverseze deșertul de la nord (prima linie) la sud(ultima linie). Pentru aceasta el poate sa aleagă oricare zonă accesibilă de pe prima line și dorește să ajungă pe ultima linie cu număr minim de pași.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>traversare.in</code> conține pe prima linie numerele <code>n m</code>. Următoarele <code>n</code> linii conțin câte <code>m</code> valori <code>0</code> sau <code>1</code>, separate prin câte un spațiu. Valoarea <code>0</code> reprezintă o zonă accesibilă, iar valoarea <code>1</code> reprezintă o zonă inaccesibilă.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>traversare.out</code> va conține pe prima linie numărul <code>C</code>, reprezentând numărul minim de pași necesari pentru traversare.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ n , m ≤ 1000</code></li>
	<li>în traversarea deșertului un pas este trecerea dintr-o zonă accesibilă în altă zonă accesibilă învecinată cu prima</li>
	<li>la determinarea numărului de pași se numără și primul pas (intrarea în matrice)</li>
	<li>pentru toate datele de test este posibilă traversarea deșertului</li>
</ul>

<br><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- link-unit -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:15px" data-ad-client="ca-pub-7152921241438800" data-ad-slot="6421896419" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0;width:728px;height:15px;" sandbox="allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="728" height="15" frameborder="0" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-7152921241438800&amp;output=html&amp;h=15&amp;slotname=6421896419&amp;adk=1130877403&amp;adf=3283908322&amp;w=728&amp;lmt=1595356630&amp;psa=1&amp;guci=1.2.0.0.2.2.0.0&amp;url=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F883%2Ftraversare&amp;flash=0&amp;wgl=1&amp;dt=1595356630434&amp;bpp=6&amp;bdt=231&amp;idt=153&amp;shv=r20200716&amp;cbv=r20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;prev_fmts=336x280%2C0x0&amp;nras=1&amp;correlator=6602292096956&amp;frm=20&amp;pv=1&amp;ga_vid=704522989.1595356494&amp;ga_sid=1595356631&amp;ga_hid=1937360318&amp;ga_fc=0&amp;iag=0&amp;icsg=17380323360767&amp;dssz=47&amp;mdo=0&amp;mso=0&amp;u_tz=180&amp;u_his=27&amp;u_java=0&amp;u_h=900&amp;u_w=1440&amp;u_ah=816&amp;u_aw=1440&amp;u_cd=30&amp;u_nplug=3&amp;u_nmime=4&amp;adx=41&amp;ady=1164&amp;biw=1200&amp;bih=649&amp;scr_x=0&amp;scr_y=0&amp;oid=3&amp;pvsid=4470135772528659&amp;pem=564&amp;ref=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F880%2Fsoarece2&amp;rx=0&amp;eae=0&amp;fc=896&amp;brdim=22%2C45%2C22%2C45%2C1440%2C23%2C1200%2C772%2C1200%2C649&amp;vis=1&amp;rsz=%7Co%7CeEbr%7C&amp;abl=NS&amp;pfx=0&amp;fu=8192&amp;bc=31&amp;ifi=2&amp;uci=a!2&amp;btvi=1&amp;fsb=1&amp;xpc=6AcqZReDv2&amp;p=https%3A//www.pbinfo.ro&amp;dtd=159" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" data-google-container-id="a!2" data-load-complete="true" data-google-query-id="CIjJicr-3uoCFdPEsgodBZsE7g"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1>Exemplu</h1>

<p><code>traversare.in</code></p>

<pre contenteditable="true" editable="true">6 9
1 1 0 0 1 1 1 0 0 
0 0 1 0 1 0 1 1 0 
1 1 0 0 0 0 0 0 0 
1 0 0 0 1 0 0 0 1 
1 0 1 1 0 1 0 0 0 
1 0 0 0 0 0 0 1 0 </pre>

<p><code>traversare.out</code></p>

<pre contenteditable="true" editable="true">8</pre>

<h1>Explicație</h1>

<p>O traversare cu <code>8</code> pași a deșertului este următoarea:</p>

<table>
		<tbody><tr>
			<td> 1 </td>
			<td> 1 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 1 </td>
			<td> 1 </td>
			<td> 1 </td>
			<td>  0  </td>
			<td> <strong>0</strong> </td>
		</tr>
		<tr>
			<td> 0 </td>
			<td> 0 </td>
			<td> 1 </td>
			<td> 0 </td>
			<td> 1 </td>
			<td> 0 </td>
			<td> 1 </td>
			<td>  1  </td>
			<td> <strong>0</strong> </td>
		</tr>
		<tr>
			<td> 1 </td>
			<td> 1 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> <strong>0</strong> </td>
			<td> <strong>0</strong> </td>
		</tr>
		<tr>
			<td> 1 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 1 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> <strong>0</strong> </td>
			<td> 1 </td>
		</tr>
		<tr>
			<td> 1 </td>
			<td> 0 </td>
			<td> 1 </td>
			<td> 1 </td>
			<td> 0 </td>
			<td> 1 </td>
			<td> 0 </td>
			<td> <strong>0</strong> </td>
			<td> <strong>0</strong> </td>
		</tr>
		<tr>
			<td> 1 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td> 0 </td>
			<td>  1  </td>
			<td> <strong>0</strong> </td>
		</tr>
</tbody></table>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;
ifstream cin("traversare.in");
ofstream cout("traversare.out");
const int di[]={-1 , 0 , 1 , 0};
const int dj[]={0 , 1 , 0 , -1};
int n , m ;
int a[1002][1002], aux[1002][1002];

int ip , jp , is , js;

struct poz{int i , j;};
poz q[1000000];

bool inside(int i , int j){return i>=1 &amp;&amp; i<=n &amp;&amp; j>=1 &amp;&amp; j<=m;}
int lee(int dr)
{
    int st;
    st=1;
    while(st<=dr)
    {
        int i = q[st].i;
        int j = q[st].j;
        if (i == n)break;
        for(int d = 0 ; d < 4 ; d++)
        {
            int inou=i+di[d];
            int jnou=j+dj[d];
            if(inside(inou,jnou) &amp;&amp; a[inou][jnou]==0)
            {
                q[++dr].i=inou;
                q[dr].j=jnou;
                a[inou][jnou]=a[i][j]+1;
            }
        }
        st++;
    }
    return a[q[st].i][q[st].j];
}
void renew()
{
    for(int i = 1 ; i <=n ; ++i)
        for(int j = 1 ; j <=m ; ++j)
            a[i][j] = aux[i][j];
}
int main()
{
    cin >> n >> m;
    for(int i = 1 ; i <=n ; ++i)
        for(int j = 1 ; j <=m ; ++j)
        {cin >> a[i][j];
        }


    int dr = 0;
    for (int j = 1; j <= m; j ++)
    {
        if (a[1][j] == 0)
        {
            poz start;
            start.i = 1;
            start.j = j;
            a[1][j] = 1;
            q[++dr] = start;
        }
    }
    cout << lee(dr);
    return 0;
}</pre>
