<p>Se dă un şir de <code>N</code> numere naturale. Din acest şir, putem forma un şir comprimat de forma:  <code>a[1]</code>, <code>b[1]</code>, <code>a[2]</code>, <code>b[2]</code>, …, <code>a[x]</code>, <code>b[x]</code>, din care înţelegem că numărul <code>a[1]</code> apare pe primele <code>b[1]</code> poziţii, <code>a[2]</code> apare pe următoarele <code>b[2]</code> poziţii…, iar <code>a[x]</code> apare pe ultimele <code>b[x]</code> poziţii.</p>

<p>De exemplu, dacă şirul dat este <code>1 1 5 5 5 2</code>, atunci şirul comprimat va fi <code>1 2 5 3 2 1</code>.</p>

<h1>Cerința</h1>

<p>Să se determine:</p>

<p>a) Lungimea celei mai lungi secvenţe formată din numere egale.<br>
b) Şirul comprimat pentru şirul dat.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>sir6.in</code> conține pe prima linie numerele <code>P</code> şi <code>N</code>. Pe următoarea linie se găseşte un şir format din <code>N</code> numere naturale.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>sir6.out</code> va conține pe prima linie:<br>
a) Dacă <code>P</code> este <code>1</code>, lungimea celei mai lungi secvenţe, reprezentând răspunsul la cerinţa a).<br>
b) Dacă <code>P</code> este <code>2</code>, şirul comprimat, reprezentând răspunsul la cerinţa b).</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>N &lt;= 100 000</code></li>
	<li>Numerele din şir nu depăşesc <code>1 000 000</code>.</li>
	<li><code>P</code> este <code>1</code> sau <code>2</code>.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>sir6.in</code></p>

<pre contenteditable="true" editable="true">1 6
1 1 5 5 5 2</pre>

<p><code>sir6.out</code></p>

<pre contenteditable="true" editable="true">3</pre>

<h3>Explicație</h3>

<p>Pentru acest test <code>P = 1</code>, deci se va rezolva doar cerinţa a). Secvenţa cea mai lungă formată din numere egale este: <code>5 5 5</code> şi are lungimea <code>3</code>.</p>

<h1>Exemplul 2</h1>

<p><code>sir6.in</code></p>

<pre contenteditable="true" editable="true">2 6
1 1 5 5 5 2</pre>

<p><code>sir6.out</code></p>

<pre contenteditable="true" editable="true">1 2 5 3 2 1</pre>

<h3>Explicație</h3>

<p>Pentru acest test <code>P = 2</code>, deci se va rezolva doar cerinţa b). Numărul <code>1</code> apare de <code>2</code> ori, numărul <code>5</code> apare de <code>3</code> ori, iar numărul <code>2</code> apare o singură dată. Prin urmare, şirul comprimat este <code>1 2 5 3 2 1</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;
ifstream cin("sir6.in");
ofstream cout("sir6.out");
int main()
{
    int c , n , a[100001] , l = 0 , lmax = 0;
    cin >> c >> n;
    for(int i = 0 ; i < n ; ++i) cin >> a[i];
    if(c == 1)
    {
        for(int i = 0 ; i < n ; ++i)
        {
            if(a[i] == a[i+1]) l++;
            if(l > lmax)lmax = l;
            if(a[i] != a[i+1]) l = 0;
        }
        cout << lmax+1;
    }
    if(c == 2)
    {
        int i = 0 , cnt = 0;
        for(i = 0 ; i < n ; ++i)
        {
            while(a[i] == a[i+1]) cnt++ , i++;
            cout << a[i] << " " << cnt+1<< " ";
            cnt = 0;
        }
    }
}</pre>
