<h1>Cerința</h1>

<p>Rică se joacă în fiecare seară The MazeRunnerVladVersion, joc pe care îl vom numi pentru simplitatea problemei MR. Jocul constă în găsirea unei căi de scăpare dintr-un labirint care conține:</p>

<ul>
	<li>ziduri prin care Rică nu va putea să treacă;</li>
	<li>zero sau mai multe teleporturi cu ajutorul cărora deplasarea între două puncte precizate <code>p1(x1, y1)</code> și <code>p2(x2, y2)</code> se face într-un minut, dacă se doreşte acest lucru;</li>
	<li>zone libere, trecerea din zona curentă într-o zonă învecinată se poate face pe direcția celor patru puncte cardinale. Deplasarea se va face într-un minut.</li>
</ul>

<p>Rică pleacă din colțul stânga-sus al labirintului și doreşte să ajungă în colțul dreapta-jos.</p>

<p>El știe că are o teză în ziua următoare, așa că vă cere ajutorul vouă, programatorilor, și vă roagă să aflați timpul minim în care poate să ajungă din colțul stânga-sus în colțul dreapta-jos al labirintului.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>mr.in</code> conține:</p>

<ul>
	<li>numărul <code>L</code> de linii și numărul <code>C</code> de coloane pentru harta labirintului, separate printr-un spațiu</li>
	<li>pe următoarele <code>L</code> linii se vor găsi <code>C</code> valori de <code>-1</code> (reprezentând zid) sau <code>0</code> separate printr-un spațiu</li>
	<li>pe linia <code>L+2</code> se va găsi numărul de teleporturi <code>T</code></li>
	<li>pe fiecare dintre următoarele <code>T</code> linii se vor găsi câte patru numere de forma: <code>L1 C1 L2 C2</code> separate printr-un spațiu, reprezentând poziţiile de pe hartă ale teleporturilor. Rică poate să aleagă să se teleporteze din poziția <code>L1 C1</code> în poziția <code>L2 C2</code>.</li>
</ul>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>mr.out</code> va conține pe prima linie timpul minim necesar lui Rică pentru a parcurge labirintul.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>2 ≤ n, m ≤ 100</code></li>
	<li><code>0 ≤ T ≤ 100</code></li>
	<li>Pentru fiecare set de date de intrare există soluție.</li>
	<li>Pentru 50% din teste nu există teleporturi.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>mr.in</code></p>

<pre contenteditable="true" editable="true">5 5
 0  0 -1 0 0 
 0 -1  0 0 0 
 0  0  0 0 0
-1 -1  0 0 0
 0  0  0 0 0
 0</pre>

<p><code>mr.out</code></p>

<pre contenteditable="true" editable="true">8</pre>

<h3>Explicație</h3>

<p>Un drum minim posibil este:</p>

<pre contenteditable="true" editable="true">(1, 1) → (2, 1) → (3, 1) → (3, 2) → (3, 3) → (4, 3) → (5, 3) → (5, 4) → (5, 5)</pre>


<h1>Exemplul 2</h1>

<p><code>mr.in</code></p>

<pre contenteditable="true" editable="true">5 6	
 0  0  0  0 -1  0
 0  0 -1 -1  0  0
-1  0  0  0 -1  0
-1  0 -1  0  0  0
-1 -1 -1  0  0  0
2
2 2 4 5
4 2 2 5</pre>

<p><code>mr.out</code></p>

<pre contenteditable="true" editable="true">5</pre>

<h3>Explicație</h3>

<p>Un drum minim posibil este:</p>

<pre contenteditable="true" editable="true">(1, 1) → (1, 2) → (2, 2) → (4, 5) → (4, 6) → (5, 6).</pre>

<p>Între pozițiile <code>(2,2)</code> și <code>(4,5)</code> s-a utilizat primul teleport.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <queue>
using namespace std;

ifstream cin("mr.in");
ofstream cout("mr.out");

const int di[] = {0 , 0 , -1 , 1};
const int dj[] = {-1 , 1 , 0 , 0};
int n , m , t , x1 , y1 , x2 , y2 , b[101][101];
struct poz
{
    int i , j;
};

struct per
{
    int it , jt , nr;
}a[101][101];
queue <poz> q;

int inside(int i , int j)
{
    return i >= 1 &amp;&amp; i <= n &amp;&amp; j >= 1 &amp;&amp; j <= m;
}

void lee()
{
    poz r;
    r.i = 1 , r.j = 1;
    b[r.i][r.j] = 1;
    q.push(r);
    while(!q.empty())
    {
        poz r;
        r = q.front();
        if(a[r.i][r.j].it)
        {
            int inou = a[r.i][r.j].it;
            int jnou = a[r.i][r.j].jt;
            if(a[inou][jnou].nr != -1 &amp;&amp; (b[inou][jnou] > b[r.i][r.j] + 1 || b[inou][jnou] == 0))
            {
                b[inou][jnou] = b[r.i][r.j] + 1;
                q.push({inou , jnou});
            }
        }
        for(int d = 0 ; d < 4 ; d++)
        {
            int inou = r.i + di[d];
            int jnou = r.j + dj[d];
            if(inside(inou , jnou) &amp;&amp; a[inou][jnou].nr != -1 &amp;&amp; b[inou][jnou] == 0)
            {
                b[inou][jnou] = b[r.i][r.j] + 1;
                q.push({inou , jnou});
            }
        }
        q.pop();
    }
}

int main()
{
    cin >> n >> m;
    for(int i = 1 ; i <= n ; i++)
        for(int j = 1 ; j <= m ; j++)
            cin >> a[i][j].nr;
    cin >> t;
    for(int i = 0 ; i < t ; i++)
    {
        cin >> x1 >> y1 >> x2 >> y2;
        a[x1][y1].it = x2;
        a[x1][y1].jt = y2;
        a[x2][y2].it = x1;
        a[x2][y2].jt = y1;
    }
    lee();
    cout << b[n][m] - 1;
}</pre>
