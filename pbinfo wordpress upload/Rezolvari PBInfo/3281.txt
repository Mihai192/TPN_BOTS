<p>Fie un șir <code>a</code><sub><code>1</code></sub>, <code>a</code><sub><code>2</code></sub>, …, <code>a</code><sub><code>N</code></sub> de numere  întregi. În acest șir se  alege o pereche de indici <code>(x, y)</code>, <code>1 ≤ x ≤ y ≤ N</code> și se inversează semnul tuturor componentelor secvenței <code>a</code><sub><code>x</code></sub>, <code>a</code><sub><code>x+1</code></sub>, …, <code>a</code><sub><code>y</code></sub>. De exemplu, pentru șirul <code>3</code>, <code>-5</code>, <code>4</code>, <code>-1</code>, <code>6</code>, <code>-8</code>, <code>-5</code>, dacă se alege perechea <code>(3, 5)</code>, atunci șirul va deveni <code>3, -5, -4, 1, -6, -8, -5</code>.</p>

<h1>Cerința</h1>

<p>Să se determine o pereche de indici <code>x y</code> astfel încât după inversarea semnului componentelor secvenței <code>a</code><sub><code>x</code></sub>, <code>a</code><sub><code>x+1</code></sub>, …, <code>a</code><sub><code>y</code></sub> suma elementelor din vector să fie minimă.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>sminus.in</code> conține pe prima linie numărul <code>N</code>. Pe a doua linie, separate prin câte un spațiu, se găsesc numerele întregi <code>a</code><sub><code>1</code></sub>, <code>a</code><sub><code>2</code></sub>, …, <code>a</code><sub><code>N</code></sub>.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>sminus.out</code> va conține două linii. Pe prima linie se vor găsi două numere naturale <code>x</code> și <code>y</code> separate printr-un spațiu reprezentând perechea de indici. Pe linia a doua se va găsi un singur număr natural reprezentând suma minimă obținută prin inversarea semnului componentelor din secvența <code>a</code><sub><code>x</code></sub>, <code>a</code><sub><code>x+1</code></sub>, …, <code>a</code><sub><code>y</code></sub>.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>2 ≤ N ≤ 100.000</code></li>
	<li><code>-1000 ≤ a</code><sub><code>i</code></sub> <code>≤ 1000</code> pentru orice <code>i = 1..N</code></li>
	<li>Secvența <code>a</code><sub><code>x</code></sub>, <code>a</code><sub><code>x+1</code></sub>, …, <code>a</code><sub><code>y</code></sub> trebuie să conțină cel puțin un element.</li>
	<li>Dacă există mai multe soluții pentru perechea <code>(x, y)</code>, atunci se va alegea aceea care are indicele <code>x</code> minim, iar dacă sunt mai multe secvențe posibile care încep la poziția <code>x</code>, se va alege aceea care are valoarea <code>y</code> maximă.</li>
	<li>Pentru teste valorând 50 de puncte, <code>N ≤ 2000</code>.</li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>sminus.in</code></p>

<pre contenteditable="true" editable="true">7
3 -5 4 -1 6 -8 -5</pre>

<p><code>sminus.out</code></p>

<pre contenteditable="true" editable="true">3 5
-24</pre>

<h3>Explicație</h3>

<p>Inversând semnul elementelor din secvența care începe la poziția <code>3</code> și se termină la poziția <code>5</code> se obține secvența <br>
<code>3</code>, <code>-5</code>, <code>-4</code>, <code>1</code>, <code>-6</code>, <code>-8</code>, <code>-5</code> care are suma elementelor egală cu <code>-24</code>.</p>

<h1>Exemplul 2:</h1>

<p><code>sminus.in</code></p>

<pre contenteditable="true" editable="true">6
2 -1 2 -2 2 -6</pre>

<p><code>sminus.out</code></p>

<pre contenteditable="true" editable="true">1 5
-9</pre>

<h3>Explicație</h3>

<p>Inversând semnul elementelor din secvența care începe la poziția <code>1</code> și se termină la poziția <code>5</code> se obține secvența <br>
<code>-2</code>, <code>1</code>, <code>-2</code>, <code>2</code>, <code>-2</code>, <code>-6</code> care are suma elementelor egală cu <code>-9</code>. Aceeași sumă minimă se putea obține și pentru perechea de indici <code>(1, 3)</code>, dar indicele <code>y</code> este mai mic.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;

ifstream cin("sminus.in");
ofstream cout("sminus.out");

int n, a[100001];

int main(){
    cin >> n;
    for(int i = 1; i <= n; ++i)
        cin >> a[i];
    int smax = 0, s = 0, st = 1, dr = 1, pozi = 1, pozj = 1;
    for(; dr <= n; ++dr){
        s+=a[dr];
        if(s < 0)
            s = 0, st = dr + 1;
        if(s >= smax)
            smax = s, pozi = st, pozj = dr;
    }
    for(int i = pozi; i <= pozj; ++i)
        a[i] *= -1;
    int sum = 0;
    for(int i = 1; i <= n; ++i)
        sum+=a[i];
    cout << pozi << ' ' << pozj << '\n' << sum;
    return 0;
}</pre>
