<p>Se consideră <code>N</code> puncte din plan, având coordonate numere naturale, relativ la un reper cartezian <code>XOY</code>, oricare două puncte fiind distincte.</p>

<h1>Cerința</h1>

<p>Cunoscând <code>N</code> și coordonatele celor <code>N</code> puncte, să se determine:</p>

<p>1) Numărul maxim de puncte care au aceeași abscisă.<br>
2) Numărul triunghiurilor care se pot desena respectând următoarele condiții:</p>

<ul>
	<li>au toate vârfurile în puncte dintre cele date;</li>
	<li>au o latură paralelă cu <code>OX</code>;</li>
	<li>nu au laturi paralele cu <code>OY</code>;</li>
</ul>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>triunghiuri2.in</code> conține pe prima linie numărul <code>p</code>, care indică cerința ce trebuie rezolvată (<code>p</code> are valoarea <code>1</code> sau <code>2</code>). Pe a doua linie se află numărul natural <code>N</code>, reprezentând numărul punctelor date. Pe următoarele <code>N</code> linii se găsesc câte două valori naturale <code>x y</code>, separate prin câte un spațiu, reprezentând coordonatele punctelor date.</p>

<h1>Date de ieșire</h1>

<p>Fișierul <code>triunghiuri2.out</code> va avea următoarea structură:</p>

<ul>
	<li>Dacă <code>p = 1</code> se va scrie în fișier, pe prima linie, numărul maxim de puncte care au aceeași abscisă (cerința 1).</li>
	<li>Dacă <code>p = 2</code> se va scrie în fișier, pe prima linie, numărul triunghiurilor care se pot desena respectând condițiile date, <code>modulo 1 000 003</code>, adică restul împărțirii numărului de triunghiuri la <code>1 000 003</code> (cerința 2).</li>
</ul>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>3 &lt;= N &lt;= 100 000</code></li>
	<li><code>0 &lt;= x &lt; 1000</code></li>
	<li><code>0 &lt;= y &lt; 1000</code></li>
	<li>Se acordă 25 puncte pentru rezolvarea corectă a cerinței 1 și 65 puncte  pentru rezolvarea corectă a cerinței 2. În concurs s-au acordat 10 puncte din oficiu. Pe site se acordă 10 puncte pentru exemple.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>triunghiuri2.in</code></p>

<pre contenteditable="true" editable="true">1
5
2 1
1 4
3 4
3 2
6 4</pre>

<p><code>triunghiuri2.out</code></p>

<pre contenteditable="true" editable="true">2</pre>

<h3>Explicație</h3>

<p>Se rezolvă cerința 1). Sunt maximum două puncte care au aceeași abscisă: <code>(3, 4)</code> și <code>(3,2)</code>.</p>

<p><img alt="" src="/resurse/9dc152/p-1700/2071-triunghiuri2.png"></p>

<h1>Exemplul 2</h1>

<p><code>triunghiuri2.in</code></p>

<pre contenteditable="true" editable="true">2
5
2 1
1 4
3 4
3 2
6 4</pre>

<p><code>triunghiuri2.out</code></p>

<pre contenteditable="true" editable="true">4</pre>

<h3>Explicație</h3>

<p>Se rezolvă cerința 2). Se pot trasa <code>4</code> triunghiuri care satisfac cerințele. Dacă notăm cele <code>5</code> puncte din fișier cu <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code> (ca în imagine), atunci, cele <code>4</code> triunghiuri care satisfac cerințele sunt : <code>ABC</code>, <code>ACE</code>, <code>ABE</code> și <code>BDE</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <vector>

#define MOD 1000003

using namespace std;

ifstream fin("triunghiuri2.in");
ofstream fout("triunghiuri2.out");

int x[1005],n,v,i,a,b,k;
long long t, aux1, aux2, aux,aux3;
vector <int> Y[1005];
vector <int> :: iterator it;

int main()
{ 
    fin>>v>>n;
    for(i=1;i<=n;++i)
    { 
        fin>>a>>b;
        x[a]++;
        Y[b].push_back(a);
    }
    if(v==1) 
    {
        a=x[0];
        for(i=0;i<=999;++i) if(x[i]>a)a=x[i];
        fout<<a<<'\n';
    }
    else
    { 
        for(i=0;i<=999;++i)
        { 
            k=Y[i].size();
            if(k>=2)
            {
                aux1=n-k;
                aux2=k*(k-1)/2;
                aux=aux1*aux2;
                for(it=Y[i].begin();it!=Y[i].end();++it)
                {
                      aux3=x[*it]-1;
                      aux3=aux3*(k-1);
                      aux=aux-aux3;
                }
            t=(t+aux)%MOD;
          }
        }
      fout<<t<<'\n';
    }
    fin.close();
    fout.close();
    return 0;
}</pre>
