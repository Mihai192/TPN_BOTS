<p>La firma de publicitate „Catchy” s-au primit <code>N</code> comenzi pentru realizarea de bannere publicitare (acestea au fost numerotate de la <code>1</code> la <code>N</code>). Angajații firmei au observat că se poate economisi foarte mult material dacă refolosesc cuvinte care au fost scrise pe bannere publicitare mai vechi, care au fost deja folosite, au fost recuperate şi au fost depozitate în magazia firmei. Acest lucru este posibil, deoarece ei folosesc întotdeauna acelaşi font, aceeaşi culoare şi aceeaşi dimensiune pentru textele scrise pe bannere. În magazia firmei sunt depozitate <code>K</code> bannere vechi. Cuvintele de pe acestea pot fi decupate integral şi reasamblate pentru a forma textul noilor bannere comandate. Caracterele speciale care separă cuvintele nu vor fi refolosite, pentru că nu este rentabil. Pentru că își doresc să fie cât mai eficienți, ei vor realiza iniţial dintre bannerele comandate doar un singur banner pentru care textul este format numai din cuvinte care se află deja scrise pe bannerele depozitate în magazie. Dacă există mai multe astfel de bannere, vor alege un banner pentru care numărul de exemplare identice ce pot fi realizate este maxim. Şi dacă şi în acest caz există mai multe bannere posibile, se va realiza bannerul cu numărul de ordine cel mai mic.</p>

<h1>Cerința</h1>

<p>Cunoscând textele scrise pe cele <code>K</code> bannere depozitate în magazia firmei, precum și textele care trebuie să fie scrise pe cele <code>N</code> bannere nou comandate, scrieţi un program care să determine bannerul care urmează să fie realizat, în condiţiile descrise în enunţul problemei.</p>

<h1>Date de intrare</h1>

<p>Pe prima linie a fișierului <code>catchy.in</code> se află numărul natural <code>K</code> reprezentând numărul de bannere din magazie. Pe următoarele <code>K</code> linii sunt scrise textele bannerelor aflate în magazia firmei, câte un text pe o linie. Pe a treia linie este scris un număr natural <code>N</code> reprezentând numărul de bannere noi. Pe următoarele <code>N</code> linii sunt scrise textele de pe bannerele noi, câte un text pe o linie.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieşire <code>catchy.out</code> va conţine două linii. Pe prima linie va fi scris numărul de ordine al bannerului ce va fi realizat. Pe a doua linie va fi scris numărul maxim de exemplare identice ce pot fi realizate din acest banner.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ k, n ≤ 150</code>;</li>
	<li>Textul scris pe orice banner este nevid şi are cel mult <code>1500</code> de caractere cu coduri <span class="caps">ASCII</span> cuprinse între <code>32</code> şi <code>127</code>;</li>
	<li>Caracterele :  <strong><em>, : ; ) ( . ? ! &gt; &lt; } {</em></strong> şi spaţiul sunt considerate caractere speciale, deoarece sunt separatori;</li>
	<li>Un cuvânt este format dintr-o succesiune nevidă de maxim <code>25</code> de caractere diferite de separatori;</li>
	<li>Oricare două cuvinte succesive în text sunt separate de unul sau mai mulţi separatori;</li>
	<li>Se face distincţie între literele mici şi literele mari;</li>
	<li>Pentru datele de test va exista cel puţin un banner care poate să fie realizat;</li>
</ul>

<br><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- link-unit -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:15px" data-ad-client="ca-pub-7152921241438800" data-ad-slot="6421896419" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0;width:728px;height:15px;" sandbox="allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="728" height="15" frameborder="0" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-7152921241438800&amp;output=html&amp;h=15&amp;slotname=6421896419&amp;adk=1130877403&amp;adf=1958414068&amp;w=728&amp;lmt=1595353211&amp;psa=1&amp;guci=1.2.0.0.2.2.0.0&amp;url=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F2565%2Fcatchy&amp;flash=0&amp;wgl=1&amp;dt=1595353211333&amp;bpp=13&amp;bdt=244&amp;idt=191&amp;shv=r20200716&amp;cbv=r20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;prev_fmts=336x280%2C0x0&amp;nras=1&amp;correlator=2968948092870&amp;frm=20&amp;pv=1&amp;ga_vid=1744050990.1595352838&amp;ga_sid=1595353211&amp;ga_hid=1227508563&amp;ga_fc=0&amp;iag=0&amp;icsg=17380323360767&amp;dssz=47&amp;mdo=0&amp;mso=0&amp;u_tz=180&amp;u_his=50&amp;u_java=0&amp;u_h=900&amp;u_w=1440&amp;u_ah=814&amp;u_aw=1440&amp;u_cd=30&amp;u_nplug=3&amp;u_nmime=4&amp;adx=41&amp;ady=1440&amp;biw=1200&amp;bih=647&amp;scr_x=0&amp;scr_y=0&amp;eid=21066706&amp;oid=3&amp;pvsid=2450571304280363&amp;pem=168&amp;ref=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F686%2Fgrad&amp;rx=0&amp;eae=0&amp;fc=896&amp;brdim=22%2C45%2C22%2C45%2C1440%2C23%2C1200%2C770%2C1200%2C647&amp;vis=1&amp;rsz=%7Co%7CeEbr%7C&amp;abl=NS&amp;pfx=0&amp;fu=8192&amp;bc=31&amp;ifi=2&amp;uci=a!2&amp;btvi=1&amp;fsb=1&amp;xpc=67t4WJwSGS&amp;p=https%3A//www.pbinfo.ro&amp;dtd=198" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" data-google-container-id="a!2" data-load-complete="true" data-google-query-id="CLGZ4Ovx3uoCFapFkQUdZ1IJ1w"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1>Exemplu</h1>

<p><code>catchy.in</code></p>

<pre contenteditable="true" editable="true">5
Acum avem multe  de castigat,    "recuperand" aceste cuvinte.
Folosim cuvinte, multe cuvinte, cuvinte din multe bannere folosite.
cuvintele folosite sunt multe valoroase; ele se 'pastreaza'.
Noi avem multe bannere in magazie care pot fi folosite.
Cuvintele sunt: cu litere mari, mici, acelasi font, fara diacritice.
6
dorim s-avem bannere valoroase.
multe cuvinte sunt valoroase.
sunt   multe, multe cuvinte.
Noi,   "recuperand" cuvintele, avem de castigat.
Vasile e de acord
avem multe.</pre>

<p><code>catchy.out</code></p>

<pre contenteditable="true" editable="true">3
2</pre>

<h3>Explicație</h3>

<p>Există <code>5</code> bannere în magazie şi avem <code>6</code> comenzi pentru bannere noi. Bannerul nou cu numărul de ordine <code>1</code> nu poate fi realizat deoarece cuvintele din care este format nu se regăsesc toate în textul bannerelor vechi (cuvintele dorim şi s-avem nu există). De asemenea bannerul nou cu numărul de ordine <code>6</code> nu poate fi realizat. Bannerele cu numerele de ordine <code>2</code>, <code>3</code> şi <code>4</code> pot fi realizate. Bannerul <code>2</code> poate fi realizat într-un singur exemplar, deoarece cuvântul valoroase poate fi decupat o singură dată. Bannerul <code>3</code> poate fi realizat în două exemplare: <br>
<img alt="" src="/resurse/968f81/catchy.jpg"><br>
Bannerul <code>4</code> poate fi realizat într-un singur exemplar. Bannerul <code>6</code> poate fi şi el realizat în două exemplare, dar deoarece bannerul <code>3</code> are numărul de ordine mai mic, îl vom alege pe acesta.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <cstring>
#include <algorithm>
using namespace std;

ifstream cin("catchy.in");
ofstream cout("catchy.out");

struct cuv
{
    string c;
    int ap;
}a[3501];
cuv b[3501];
int n , k , na , nb , ales , rad , ns , nt;

string S[100001] , T[100001];
int apare(cuv a[] , int n , string s)
{
    for(int i = 1  ;i <= n ; i++)
        if(s == a[i].c) return i;
    return 0;
}

int cautarebinara(cuv a[] , int n , string s)
{
    int st = 1 , dr = n;
    while(st <= dr)
    {
        int m = (st + dr) / 2;
        if(a[m].c == s) return m;
        else if(a[m].c > s) dr = m - 1;
        else st = m + 1;
    }
    return 0;
}

int maimic(cuv a , cuv b)
{
    return a.c < b.c;
}
int main()
{
    cin >> k;
    cin.get();
    char s[1501] , sep[] = " ,:;)(.?!><}{";
    string cuv;
    for(int i = 1 ; i <= k ; i++)
    {
        cin.getline(s , 1501);
        char *p = strtok(s , sep);
        while(p)
        {
            S[++ns] = p;
            p = strtok(NULL , sep);
        }
    }
    sort(S + 1 , S + ns+1);
    na = 1;
    a[na].c = S[1];
    a[na].ap = 1;
    for(int i = 2 ; i <= ns ; i++)
        if(S[i] == S[i-1]) a[na].ap++;
        else
        {
            na ++;
            a[na].ap = 1;
            a[na].c = S[i];
        }
    cin >> n;
    cin.get();

    for(int i = 1 ; i <= n ; i++)
    {
        nt = 0;
        cin.getline(s , 1501);
        char *p = strtok(s , sep);
        while(p)
        {
            T[++nt] = p;
            p = strtok(NULL , sep);
        }
        sort(T + 1 , T + nt + 1);
        nb = 1;
        b[nb].c = T[1];
        b[nb].ap = 1;
        for(int i = 2 ; i <= nt ; i++)
            if(T[i] == T[i-1]) b[nb].ap++;
            else
            {
                nb ++;
                b[nb].ap = 1;
                b[nb].c = T[i];
            }

        int rmin= 100000;
        for(int j = 1 ; j <= nb ; j++)
        {
            int poz = cautarebinara(a , na , b[j].c);
            if(poz == 0) rmin = 0;
            else if(a[poz].ap / b[j].ap < rmin)
                rmin = a[poz].ap / b[j].ap;
        }
        if(rmin > rad)
        {
            rad = rmin;
            ales = i;
        }
    }
    cout << ales << endl << rad;

}</pre>
