<p>Este anul 2019, dar Zmeul-Cel-Rău și Făt-Frumos luptă în continuare. Zmeul l-a prins pe Făt-Frumos şi l-a închis în una dintre camerele bârlogului său. Un bârlog de zmeu are forma unui tablou bidimensional, în care camerele sunt plasate sub forma a <code>n</code> linii și <code>m</code> coloane. Vom numerota liniile de la <code>1</code> la <code>n</code>, iar coloanele de la <code>1</code> la <code>m</code>, astfel că fiecare cameră poate fi identificată prin numărul liniei și al coloanei pe care se află. </p>

<p>Orice cameră are patru pereți și câte o ușă pe fiecare perete prin care poate comunica cu camerele învecinate. Mai exact, camera de pe linia <code>i</code> și coloana <code>j</code> poate comunica cu camerele <code>(i-1,j)</code>, <code>(i,j+1)</code>, <code>(i+1,j)</code>, <code>(i,j-1)</code> (desigur, dacă acestea există). Fiecare cameră are asociat un cod. Ușile din orice cameră se pot deschide cu o cartelă magnetică. Dacă codul camerei este un subșir al cuvântului memorat pe cartela magnetică, atunci ușile din camera respectivă se vor deschide folosind cartela. Ileana Cosânzeana a reușit să-i trimită lui Făt-Frumos o cartelă magnetică.</p>

<h1>Cerința</h1>

<p>Scrieți un program care rezolvă următoarele două cerințe:<br>
1. determină numărul de camere în care ar putea ajunge Făt-Frumos folosind cartela primită de la Ileana Cosânzeana;<br>
2. determină numărul minim de camere prin care trece Făt-Frumos pentru a ieși din bârlogul zmeului (adică poate deschide ușa unei camere prin care ajunge în exteriorul bârlogului).</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>barlog.in</code> conține pe prima linie cerința <code>c</code> care trebuie să fie rezolvată (<code>1</code> sau <code>2</code>). Pe a doua linie se află două numere naturale <code>n m</code>, reprezentând numărul de linii și respectiv numărul de coloane ale tabloului care reprezintă bârlogul zmeului. Pe următoarele <code>n</code> linii se află câte <code>m</code> cuvinte, reprezentând în ordine codurile de acces ale camerelor din bârlogul zmeului. Pe ultima linie sunt două numere naturale și un cuvânt <code>lin col cuv</code>, reprezentând linia și coloana camerei în care a fost închis Făt-Frumos, precum și cuvântul înscris pe cartela magnetică primită de Făt-Frumos de la Ileana Cosânzeana. Valorile scrise pe aceeași linie sunt separate prin câte-un spațiu.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>barlog.out</code> va conține o singură linie pe care va fi scris un număr natural determinat conform cerinței <code>c</code>.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>2 ≤ n, m ≤ 100</code></li>
	<li>Codurile camerelor și cuvântul de pe cartelă sunt cuvinte nevide, formate din maximum <code>20</code> de litere mici ale alfabetului englez.</li>
	<li>Pentru datele de test, Făt-Frumos va putea ieși întotdeauna din bârlogul zmeului.</li>
	<li>Cuvântul <code>a</code> este un subșir al cuvântului <code>b</code> dacă literele din <code>a</code> se găsesc în <code>b</code> în aceeași ordine. De exemplu <code>arma</code> este un subșir al cuvântului <code>marama</code>, dar nu și al cuvântului <code>tamara</code>.</li>
	<li>Pentru teste valorând <code>40%</code> din punctaj cerința este <code>1</code>.</li>
	<li>În concurs s-au acordat <code>10</code> puncte din oficiu. Aici se acordă pentru testele din exemple.</li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>barlog.in</code></p>

<pre contenteditable="true" editable="true">1
5 4
ana are mere bune
dana cere pere multe
cra ana vrea pere
dar dan nu are
sunt bune pe care
3 2 caravana</pre>

<p><code>barlog.out</code></p>

<pre contenteditable="true" editable="true">7</pre>

<h1>Exemplul 2:</h1>

<p><code>barlog.in</code></p>

<pre contenteditable="true" editable="true">2
5 4
ana are mere bune
dana cere pere multe
cra ana vrea pere
dar dan nu are
sunt bune pe care
3 2 caravana</pre>

<p><code>barlog.out</code></p>

<pre contenteditable="true" editable="true">2</pre>

<h1>Explicație</h1>

<p>Camerele în care poate intra Făt-Frumos sunt: <code>(3,2)</code>, <code>(3,3)</code>, <code>(2,2)</code>, <code>(3,1)</code>, <code>(4,2)</code>, <code>(2,1)</code>, <code>(4,1)</code>. Poate ieși din bârlog prin camera <code>(3,1)</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;

ifstream cin("barlog.in");
ofstream cout("barlog.out");

#define MaxN 101
#define Smax 21
#define Inf 0x3f3f3f

int cer, n, m, Xf, Yf;
bool ok[MaxN][MaxN];
char mat[MaxN][MaxN][Smax];
int dist[MaxN][MaxN] = {Inf} , nr;

struct poz
{
    int i , j;
};

const int di[] = {0, 0, 1, -1};
const int dj[] = {1, -1, 0, 0};

queue <poz>Q;
int inside(int i , int j)
{
    return i >= 1 &amp;&amp; i <= n &amp;&amp; j >= 1 &amp;&amp; j <= m;
}

void lee(int i , int j)
{
    poz x;
    x.i = i;
    x.j = j;
    Q.push(x);
    nr++;
    dist[i][j] = 1;
    while(!Q.empty())
    {
        x = Q.front();
        for(int i = 0 ; i < 4 ; i++)
        {
            int inou = x.i + di[i];
            int jnou = x.j + dj[i];
            if(inside(inou , jnou) &amp;&amp; ok[x.i][x.j] == 1 &amp;&amp; dist[inou][jnou] == 0)
            {
                poz y;
                y.i = inou;
                y.j = jnou;
                Q.push(y);
                dist[inou][jnou] = dist[x.i][x.j] + 1;
                nr++;
            }
        }
        Q.pop();
    }
}

bool searchs(char a[], char b[])
{
    int i = 0, n = strlen(a);
    int indb = 0, lb = strlen(b);
    while (i < n)
    {
        if (a[i] == b[indb])i ++, indb ++;
        else i ++;
        if (indb == lb)return 1;
    }
    return 0;
}
int main()
{
    char cheie[Smax];

    cin >> cer >> n >> m;
    for (int i = 1; i <= n; ++ i)
        for (int j = 1; j <= m; ++ j)
            cin >> mat[i][j];

    cin >> Xf >> Yf;
    cin >> cheie;

    int nr1 = 0;
    for (int i = 1; i <= n; ++ i)
        for (int j = 1; j <= m; ++ j)
        {
            if (searchs(cheie, mat[i][j]))
            {
                ok[i][j] = 1;

            }
        }
        lee(Xf, Yf);
        int dmin = Inf;
        for(int i = 1; i <= n; ++ i)
        {
            if(dist[i][1] != 0 &amp;&amp; ok[i][1] == 1)
                dmin = min(dmin, dist[i][1]);
            if(dist[i][m] != 0 &amp;&amp; ok[i][m] == 1)
                dmin = min(dmin, dist[i][m]);
        }

        for (int i = 1; i <= m; ++ i)
        {
            if(dist[1][i] != 0 &amp;&amp; ok[1][i] == 1)
                dmin = min(dmin, dist[1][i]);
            if(dist[n][i] != 0 &amp;&amp; ok[n][i] == 1)
                dmin = min(dmin, dist[n][i]);
        }
    if(cer == 2)cout << dmin;
    else cout << nr;
    return 0;
}</pre>
