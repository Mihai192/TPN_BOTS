<p>Se consideră un șir format din <code>n</code> numere naturale. Asupra numerelor din șir se face următoarea prelucrare: fiecare valoare este înlocuită cu cel mai mare divizor prim al său. În noul șir se formează secvențe de numere care încep și se termină cu aceeași valoare, numite secvențe neuniforme.</p>

<h1>Cerința</h1>

<p>Cunoscând numerele naturale <code>n</code> și <code>c</code>, și un șir de <code>n</code> numere naturale, se cere să se rezolve următoarele cerințe: <br>
1. dacă <code>c = 1</code>, atunci se cere să se afișeze lungimea maximă a unei secvențe neuniforme.<br>
2. dacă <code>c = 2</code>, atunci se cere să se afișeze numărul total de secvențe neuniforme din șir.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>numere.in</code> conține pe prima linie, despărțite prin câte un spațiu, numerele naturale <code>n</code> și <code>c</code>, cu semnificația din enunț. A doua linie conține <code>n</code> numere naturale, despărțite prin câte un spațiu. </p>

<h1>Date de ieșire</h1>

<p>Dacă <code>c = 1</code>, atunci pe prima linie a fișierului <code>numere.out</code> va fi scris un singur număr ce reprezintă lungimea maximă a unei secvențe neuniforme. Dacă <code>c = 2</code>, atunci fișierul <code>numere.out</code> va conține un singur număr ce reprezintă numărul total de secvențe neuniforme.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>0 &lt; n &lt; 10.000</code></li>
	<li><code>1 &lt; valoare din șir &lt; 10.000</code></li>
	<li><code>lungimea unei secvențe ≥ 2</code></li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>numere.in</code></p>

<pre contenteditable="true" editable="true">6  1
14 2 49 3 35 1024  </pre>

<p><code>numere.out</code></p>

<pre contenteditable="true" editable="true">5</pre>

<h3>Explicație</h3>

<p>Cele <code>6</code> numere sunt înlocuite cu valorile: <code>7</code>, <code>2</code>, <code>7</code>, <code>3</code>, <code>7</code>, <code>2</code>. Lungimea celei mai lungi secvențe neuniforme este <code>5</code>; secvențele neuniforme cu acestă lungime sunt <code>7</code>, <code>2</code>, <code>7</code>, <code>3</code>, <code>7</code> sau <code>2, 7, 3, 7, 2</code>.</p>

<h1>Exemplul 2:</h1>

<p><code>numere.in</code></p>

<pre contenteditable="true" editable="true">10 2
14 8 3 25 6 24 20 1024 100 2</pre>

<p><code>numere.out</code></p>

<pre contenteditable="true" editable="true">9</pre>

<h3>Explicație</h3>

<p>Cele <code>10</code> numere sunt înlocuite cu valorile: <code>7</code>, <code>2</code>, <code>3</code>, <code>5</code>, <code>3</code>, <code>3</code>, <code>5</code>, <code>2</code>, <code>5</code>, <code>2</code>. Numărul total de secvențe neuniforme din șir este <code>3 + 3 + 3 = 9</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;

int n , a[10001];

struct perechi{
    int p1 , p2 , val;
}f[10001];


ifstream cin("numere.in");
ofstream cout("numere.out");

bool prim(int x)
{
    int cnt = 0;
    for(int d = 1 ; d * d <= x ; ++d)
    {
        if(x % d == 0)
            cnt+=2;
        if(d * d == x)
            cnt--;
    }
    return cnt == 2;
}

int divi(int x)
{
    int max = 0;
    for(int d = 1 ; d * d <= x ; ++d)
    {
        if(x % d == 0)
        {
            if(prim(x/d) &amp;&amp; x / d > max)
                max = x / d;
            if(prim(d) &amp;&amp; d > max)
                max = d;
        }
    }
    return max;
}

int main()
{
    int c;
    cin >> n >> c;
    int x;
    for(int i = 1 ; i <= n ; ++i)
        cin >> x , a[i] = divi(x);
    for(int i = 1 ; i <= n ; ++i)
    {
        if(f[a[i]].val==0)
            f[a[i]].p1=i , f[a[i]].p2=i , f[a[i]].val++;
        else
            f[a[i]].p2=i , f[a[i]].val++;
    }
    if(c == 1)
    {
        int max = 0;
        for(int i = 1 ; i <= 10000 ; ++i)
            if(f[i].p2 - f[i].p1 + 1 > max)
                max = f[i].p2 - f[i].p1 + 1;
            cout << max << endl;
    }
    else
    {
        unsigned long long cnt = 0;
        for(int i = 1 ; i <= 10000 ; ++i)
            if(f[i].val > 1)
            cnt = cnt + f[i].val * (f[i].val-1) / 2;
        cout << cnt << endl;
    }
    return 0;
}</pre>
