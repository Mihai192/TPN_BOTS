<p>Un șir format din <code>2•n</code> numere naturale se numește <strong>paritar</strong> dacă fiecare dintre primii săi <code>n</code> termeni fie are aceeași paritate cu oricare dintre ultimii săi <code>n</code> termeni, fie este strict mai mic decât oricare număr de paritate diferită aflat printre aceștia.</p>

<h1>Cerința</h1>

<p>Dându-se un șir de <code>2•n</code> numere naturale, să se afișeze mesajul <code>DA</code>, în cazul în care șirul aflat în fișier este paritar, sau mesajul <code>NU</code>, în caz contrar. Proiectați un algoritm eficient din punctul de vedere al timpului de executare și al memoriei utilizate.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>paritar.in</code> conține pe prima linie numărul <code>n</code>, iar pe a doua linie <code>2•n</code> numere naturale separate prin spații reprezentând elementele șirului.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>paritar.out</code> va conține pe prima linie mesajul <code>DA</code>, dacă șirul este paritar, sau mesajul <code>NU</code> dacă șirul nu este paritar.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ n ≤ 250.000</code></li>
	<li>numerele de pe a doua linie a fișierului de intrare vor fi mai mici decât <code>1.000.000</code></li>
	<li>Enunțul original nu specifică nimic pentru cazul când în primii <code>n</code> termeni există și numere pare și impare, dar în ultimele <code>n</code> sunt doar nume pare (sau doar impare). În acest caz, dacă în ultimii <code>n</code> termeni nu sunt numere pare, atunci vom presupune că toate numerele impare din primele <code>n</code> sunt mai mici decât orice număr par. Și simetric, dacă în ultimii <code>n</code> termeni nu sunt numere impare, atunci vom presupune că toate numerele pare din primele <code>n</code> sunt mai mici decât orice număr impar.</li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>paritar.in</code></p>

<pre contenteditable="true" editable="true">5
20 3 11 4 15 25 49 18 53 16</pre>

<p><code>paritar.out</code></p>

<pre contenteditable="true" editable="true">DA</pre>

<h1>Exemplul 2:</h1>

<p><code>paritar.in</code></p>

<pre contenteditable="true" editable="true">3
8 16 4 10 10 6</pre>

<p><code>paritar.out</code></p>

<pre contenteditable="true" editable="true">DA</pre>

<h1>Exemplul 3:</h1>

<p><code>paritar.in</code></p>

<pre contenteditable="true" editable="true">3
8 6 4 10 7 6</pre>

<p><code>paritar.out</code></p>

<pre contenteditable="true" editable="true">NU</pre>

<h1>Exemplul 4:</h1>

<p><code>paritar.in</code></p>

<pre contenteditable="true" editable="true">3
20 30 5 8 18 6</pre>

<p><code>paritar.out</code></p>

<pre contenteditable="true" editable="true">DA</pre>

<h1>Explicație</h1>

<p>În primele <code>n</code> numere sunt două numere pare, iar în ultimele <code>n</code> numere nu există numere impare. Vom presupune deci că <code>20</code> și <code>30</code> sunt mai mici decât orice număr impar.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;

ifstream cin("paritar.in");
ofstream cout("paritar.out");

int max1 , max2 , min1 = 2000000000 , min2 = 2000000000;

int main()
{
    int n , x;
    cin >> n;
    for(int i = 1 ; i <= n ; i++)
    {
        cin >> x;
        if(x % 2 == 1) max1 = max(max1 , x);
        else max2 = max(max2 , x);
    }
    for(int i = n + 1 ; i <= 2 * n ; i++)
    {
        cin >> x;
        if(x % 2 == 1) min1 = min(min1 , x);
        else min2 = min(min2 , x);
    }
    if(max1 == 0 &amp;&amp; min1 == 2000000000) cout << "DA";
    else if(max2 == 0 &amp;&amp; min2 == 2000000000) cout << "DA";
    else if(max1 < min2 &amp;&amp; max2 < min1) cout << "DA";
    else cout << "NU";

}</pre>
