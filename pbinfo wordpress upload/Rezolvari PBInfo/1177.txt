<p>Se consideră o listă liniară simplu înlănțuită, alocată dinamic, în care elementele sunt de tipul declarat mai jos:</p>

<pre class="code_c cm-s-default" data-lang="text/x-csrc" contenteditable="true" editable="true"><span class="cm-keyword">struct</span> <span class="cm-variable">nod</span>{
    <span class="cm-keyword">int</span> <span class="cm-variable">info</span>;
    <span class="cm-variable">nod</span> <span class="cm-operator">*</span> <span class="cm-variable">urm</span>;
};</pre>

<p>în care câmpul <code>info</code> memorează un număr natural, iar câmpul <code>urm</code> memorează adresa următorului element al listei.</p>

<h1>Cerinţa</h1>

<p>Să se scrie o funcție C++ cu următorul prototip:</p>

<pre class="code_c cm-s-default" data-lang="text/x-csrc" contenteditable="true" editable="true"><span class="cm-keyword">void</span> <span class="cm-variable">sterge</span>(<span class="cm-variable">nod</span> <span class="cm-operator">*</span> <span class="cm-operator">&amp;</span> <span class="cm-variable">p</span>, <span class="cm-variable">nod</span> <span class="cm-operator">*</span> <span class="cm-variable">q</span>);</pre>

<p>care elimină, dacă există, din lista pentru care primul element are adresa memorată în pointerul <code>p</code> elementul cu adresa memorată în <code>q</code>. </p>

<h1>Restricții și precizări</h1>

<ul>
	<li>lista va conține cel puțin un element;</li>
	<li>la adresa <code>q</code> se află un element al listei;</li>
	<li>dacă <code>q == p</code>, primul element se va modifica. La ieșirea din apel, <code>p</code> va memora adresa primului element din lista modificată.</li>
</ul>

<h1>Important</h1>

<p>Soluţia propusă va conţine definiţia funcţiei cerute. Prezenţa în soluţie a altor instrucţiuni poate duce erori de compilare sau de execuţie care vor avea ca efect depunctarea soluţiei.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">void sterge(nod * &amp; p, nod * q)
{
    if (q == p)
    {
        p = p -> urm;
        return;
    }
    nod* pe = p;
    while(pe -> urm != q)///pana la ultimul
        pe = pe -> urm;

    if (q == NULL)pe -> urm = NULL;
    else pe -> urm = q -> urm;
}</pre>
