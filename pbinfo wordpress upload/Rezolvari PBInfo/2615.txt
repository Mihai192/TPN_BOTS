<h1>Cerința</h1>

<p>Se citește un text de maxim <code>256</code> caractere. Să se afișeze textul după aplicarea <code>Cifrului Caesar</code>.</p>

<p><code>Cifrul Caesar</code> este o metodă de criptare în care fiecare <b>literă</b> este înlocuită cu o <b>altă literă</b> ce se află la un număr fix de poziții după aceasta în alfabet. Este numită după Julius Caesar, care o folosea în corespondența privată. </p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>caesar.in</code> conține:<br>
</p><ol>
	<li>Pe prima linie un text format din maxim <code>256</code> caractere.</li>
	<li>Pe a doua linie un număr <code>n</code> reprezentând numărul de poziții.</li>
	<li>Pe a treia linie operația ce se va aplica pe text:</li><br>
<ul>
	<li><code>encrypt</code> pentru criptare.</li>
	<li><code>decrypt</code> pentru decriptare.</li><br>
</ul><br>
</ol><p></p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>dbftbs.out</code> va conține textul prelucrat.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ n ≤ 100</code></li>
	<li>Se va folosi alfabetul englez. Literele își păstrează capitalizarea.</li>
	<li>Atenție la exemple!</li>
</ul>

<h1>Exemple:</h1>

<h3>Exemplu #1</h3>

<p><code>caesar.in</code></p>

<pre contenteditable="true" editable="true">caesar
1
encrypt</pre>

<p><code>dbftbs.out</code></p>

<pre contenteditable="true" editable="true">dbftbs</pre>

<h3>Exemplu #2</h3>

<p><code>caesar.in</code></p>

<pre contenteditable="true" editable="true">dbftbs
1
decrypt</pre>

<p><code>dbftbs.out</code></p>

<pre contenteditable="true" editable="true">caesar</pre>

<h3>Exemplu #3</h3>

<p><code>caesar.in</code></p>

<pre contenteditable="true" editable="true">caeSaR
10
encrypt</pre>

<p><code>dbftbs.out</code></p>

<pre contenteditable="true" editable="true">mkoCkB</pre>

<h3>Exemplu #4</h3>

<p><code>caesar.in</code></p>

<pre contenteditable="true" editable="true">CAEsAr
10
decrypt</pre>

<p><code>dbftbs.out</code></p>

<pre contenteditable="true" editable="true">SQUiQh</pre>

<h3>Exemplu #5</h3>

<p><code>caesar.in</code></p>

<pre contenteditable="true" editable="true">If he had anything confidential to say, he wrote it in cipher, that is, by so changing the order of the 26 letters of the alphabet, that not a word could be made out.
7
encrypt</pre>

<p><code>dbftbs.out</code></p>

<pre contenteditable="true" editable="true">Pm ol ohk hufaopun jvumpkluaphs av zhf, ol dyval pa pu jpwoly, aoha pz, if zv johunpun aol vykly vm aol 26 slaalyz vm aol hswohila, aoha uva h dvyk jvbsk il thkl vba.</pre>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <cstring>
using namespace std;

ifstream cin("caesar.in");
ofstream cout("dbftbs.out");

char s[300], cer[20];
int n;

bool LM(char ch)
{
    return ch >= 'A' &amp;&amp; ch <= 'Z';
}

bool lm(char ch)
{
    return ch >= 'a' &amp;&amp; ch <= 'z';
}

int main()
{
    cin.getline(s, 260);
    cin >> n;
    cin >> cer;
    n=n%26;
    if(strcmp(cer, "encrypt") == 0)
    {
        int i = 0;
        while(s[i])
        {
            if(lm(s[i]) || LM(s[i]))
            {
                if(LM(s[i]))
                {
                    int nr = s[i] + n;
                    if(nr > 'Z')
                        s[i] = nr - 'Z' + 'A' - 1;
                    else
                        s[i] = nr;
                }
                else
                {
                    int nr = s[i] + n;
                    if(nr > 'z')
                        s[i] = nr - 'z' + 'a' - 1;
                    else
                        s[i] = nr;
                }
            }
            i++;
        }
        cout << s;
    }
    else
    {
        int i = 0;
        while(s[i])
        {
            if(LM(s[i]) || lm(s[i]))
            {
                if(LM(s[i]))
                {
                    s[i] = s[i] - n;
                    if(s[i] < 'A')
                        s[i] += 'Z' - 'A' + 1;
                }
                else
                {
                    s[i] = s[i] - n;
                    if(s[i] < 'a')
                        s[i] += 'z' - 'a' + 1;
                }
            }
            i++;
        }
        cout << s;
    }
    return 0;
}</pre>
