<p><em>Plouă, plouă, plouă</em>…</p>

<p><strong>IT</strong> -istul <strong>Ghită</strong> vă propune următoarea problemă:<br>
pe o platformă sunt montate pe poziții consecutive <code>n</code> bare verticale de lățime <code>1cm</code> (<em>vezi exemplul</em>). Vom presupune că platforma este mărginită față/spate de ziduri transparente de înălțime infinită. Cantitatea de apă ce poate fi reținută într-o unitate de volum (<code>1cm x 1cm x 1cm</code>) este de <code>1</code> mililitru.</p>

<h1>Cerința</h1>

<p>Determinați cantitatea maximă de apă reținută (exprimată în mililitri).</p>

<h1>Date de intrare</h1>

<p>Programul citește de la tastatură numărul <code>n</code>, iar apoi <code>n</code> numere naturale, separate prin spații, ce reprezintă înălțimile barelor.</p>

<h1>Date de ieșire</h1>

<p>Programul va afișa pe ecran numărul <code>W</code>, ce reprezintă cantitatea de apă ce poate fi reținută.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>2 ≤ n ≤ 100.000</code></li>
	<li>cele <code>n</code> numere citite vor fi mai mici decât <code>1.000</code></li>
</ul>

<h1>Exemple:</h1>

<p><strong>Intrare</strong></p>

<pre contenteditable="true" editable="true">6
3 0 0 2 0 4</pre>

<p><strong>Ieșire</strong></p>

<pre contenteditable="true" editable="true">10</pre>

<pre contenteditable="true" editable="true">12
0 1 0 2 1 0 1 3 2 1 2 1</pre>

<p><strong>Ieșire</strong></p>

<pre contenteditable="true" editable="true">6</pre>

<h3>Explicație</h3>

<p>Pentru primul exemplu:</p>

<p><img alt="" src="https://www.pbinfo.ro/resurse/d7bfda/water%20trap1.jpg"></p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <iostream>

using namespace std;

#define MAX 100001
int n;
int a[MAX], sum;

int c[MAX], s[MAX], indc, inds;

int main()
{
    int bef = 0, sbef = 0;

    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];

    c[++indc] = 1;
    s[++inds] = 0;

    for (int i = 2; i <= n; i++)
    {
        bef = 0;
        sbef = 0;
        while (a[c[indc]] < a[i])
        {
            bef = c[indc];
            sbef = s[inds];
            inds --;
            indc --;
            if (indc == 0)break;
        }

        if (indc == 0)s[++inds] = a[bef] * (i - bef - 1) + sbef, sum += a[bef];
        else s[++inds] = (a[i] * (i - c[indc] - 1));

        c[++indc] = i;
    }

    while (inds)
        sum += s[inds], inds --;

    while (indc)
        sum += a[c[indc]], indc --;

    for (int i = 1; i <= n; i++)
        sum -= a[i];

    cout << sum;
    return 0;
}</pre>
