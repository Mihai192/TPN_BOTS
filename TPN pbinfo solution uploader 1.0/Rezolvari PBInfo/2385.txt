<h1>Enunț</h1>

<p>Pe un continent reprezentat printr-o matrice cu <code>n</code> linii și <code>m</code> coloane se află mai multe state, toate în conflict. Astfel, fiecare si-a mobilizat oastea. <br>
Fiecare element al matricei memorează câte o cifră. Două elemente învecinate pe linie sau pe coloană (nu si pe diagonală) aparțin aceluiași stat și se numesc regiuni. <br>
O poziție <code>(i,j)</code> a unei regiuni din matrice este dată de indicele <code>i</code> de linie și indicele <code>j</code> coloană al elementului din matrice corespunzător acestei regiuni. <br>
O poziție din matrice ce contine cifra <code>0</code> este o regiune neutră si nu are soldați, iar poziția ce conține o cifră <code>c</code> nenulă este o regiune ce aparține unui stat și are <code>c</code> soldați.</p>

<h1>Cerința</h1>

<p>Să se determine numărul maxim de soldați dintr-o regiune a statului care are cei mai mulți soldați, precum și poziția acestei regiuni în matrice (linia și coloana).</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>oaste.in</code> conține pe prima linie numerele naturale <code>n</code> si <code>m</code>, iar pe fiecare dintre următoarele <code>n</code> linii conține câte <code>m</code> cifre, separate prin câte un spațiu.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>oaste.out</code> va conține pe prima linie trei numere separate prin cate un spațiu, reprezentând numărul maxim de soldați dintr-o regiune a statului care are cei mai mulți soldați, respectiv linia și coloana poziției acestei regiuni in matrice.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>n</code> si <code>m</code> vor fi numere naturale cu valori intre <code>1</code> si <code>100</code> inclusiv;</li>
	<li>fiecare element al matricei va avea valori naturale cuprinse intre <code>0</code> si <code>9</code> inclusiv;</li>
	<li>există cel puțin o cifră nenula în matrice</li>
	<li>spunem ca un stat are coordonatele <code>(i,j)</code> în matrice dacă regiunea din poziția <code>(i,j)</code> aparține acestui stat și este regiunea cu cea mai mică poziție în sens lexicografic dintre regiunile statului.</li>
	<li>perechea <code>(i,j)</code> este mai mică în sens lexicografic ca perechea <code>(x,y)</code> dacă <code>i&lt;x</code> sau dacă <code>i=x</code> și <code>j&lt;y</code></li>
	<li>dacă există două state cu același număr de soldați și același număr maxim de soldați într-o regiune, se va lua în considerare regiunea cu cea mai mică poziție din statul cu coordonatele cele mai mici în sens lexicografic</li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>oaste.in</code></p>

<pre contenteditable="true" editable="true">4 6
0 1 1 0 2 5
9 0 2 0 1 0
0 1 1 0 0 2
0 0 1 1 1 1</pre>

<p><code>oaste.out</code></p>

<pre contenteditable="true" editable="true">2 2 3</pre>

<h3>Explicație</h3>

<p>Harta din fișierul de intrare contine <code>3</code> state. Statul cu culoarea rosie in imagine are cei mai multi soldati iar regiunea din pozitia <code>(2,3)</code> are cei mai multi soldati referitor la celelalte regiuni din acest stat.</p>

<p><img alt="" src="https://ibb.co/h5GLg"><br>
<a href="https://imgbb.com/"><img src="https://image.ibb.co/eJ5Znc/desen.png" alt="desen" border="0"></a></p>

<h1>Exemplul 2:</h1>

<p><code>oaste.in</code></p>

<pre contenteditable="true" editable="true">4 6
0 1 1 1 1 1
0 0 0 0 0 1
2 2 2 0 0 2
0 0 2 0 0 0</pre>

<pre contenteditable="true" editable="true">2 3 6</pre>

<h3>Explicație</h3>

<p><br>
Harta din fișierul de intrare contine <code>2</code> state, ambele având câte <code>8</code> soldați. Regiunea cu număr maxim de soldați luată în considerare este cea din statul cu coordonatele <code>(1,2)</code>. Poziția acestei regiuni este <code>(3,6)</code>. <br>
Exemplu propus de <code>Tompea Viorel</code></p>

<p><img alt="" src="https://ibb.co/h5GLg"><br>
<a href="https://imgbb.com/"><img src="https://image.ibb.co/gUyfF7/img2.png" alt="img2" border="0"></a></p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;

ifstream cin("oaste.in");
ofstream cout("oaste.out");

int a[102][102] , b[102][102];

void fill(int i , int j , int &amp;c)
{
    if(a[i][j]!=0)
    {
        c+=a[i][j];
        a[i][j]=0;
        if(a[i+1][j]!=0)
            fill(i+1 , j , c);
        if(a[i-1][j]!=0)
            fill(i-1 , j , c);
        if(a[i][j-1]!=0)
            fill(i , j-1 , c);
        if(a[i][j+1]!=0)
            fill(i , j+1 , c);
    }
}

int ifi=0 , jfi=0;

void fill1(int i , int j , int &amp;max)
{
    if(b[i][j]!=0)
    {
        if(b[i][j]>max)
            max=b[i][j] , ifi=i , jfi=j;
        if(b[i][j]==max)
        {
            if(i < ifi)
                ifi=i , jfi=j;
            if(i == ifi &amp;&amp; j < jfi)
                jfi=j;
                
        }
        b[i][j]=0;
        if(b[i+1][j]!=0)
            fill1(i+1 , j , max);
        if(b[i-1][j]!=0)
            fill1(i-1 , j , max);
        if(b[i][j-1]!=0)
            fill1(i , j-1 , max);
        if(b[i][j+1]!=0)
            fill1(i , j+1 , max);
    }
}

void fill2(int i , int j)
{
    if(b[i][j]!=0)
    {
        b[i][j]=0;
        if(b[i+1][j]!=0)
            fill2(i+1 , j);
        if(b[i-1][j]!=0)
            fill2(i-1 , j);
        if(b[i][j-1]!=0)
            fill2(i , j-1);
        if(b[i][j+1]!=0)
            fill2(i , j+1);
    }
}

int main()
{
    int n , m;
    cin >> n >> m;
    int cnt=0;
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= m ; ++j)
            cin >> a[i][j] , b[i][j]=a[i][j];
    int max=0 , lmax=0;
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= m ; ++j)
            if(a[i][j]!=0)
            {
                cnt++;
                int c=0;
                fill(i , j , c);
                if(c > max)
                    max = c , lmax=cnt;
            }
    max=0;
    cnt=0;
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= m ; ++j)
            if(b[i][j]!=0)
            {
                cnt++;
                if(cnt==lmax)
                {
                    fill1(i , j , max);
                    break;
                }
                else
                    fill2(i , j);
            }
    cout << max << ' ' << ifi << ' ' << jfi;
    return 0;
}</pre>
