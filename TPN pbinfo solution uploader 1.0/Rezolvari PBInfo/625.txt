<p>Harry se află într-un duel de vrăjitori și vrea să folosească cea mai puternică vrajă pe care și-o amintește în acest moment. Deoarece mai devreme a fost lovit de o vrajă a uitării, are nevoie de ajutorul vostru pentru a calcula rapid cea mai puternică vrajă dintr-un set de vrăji. Vrăjile sunt șiruri de caractere, litere mici ale alfabetului englez, fară spații între ele.<br>
Exemple: <code>stupefy</code>, <code>accio</code>, <code>expelliarmus</code>, <code>depulso</code>, <code>levicorpus</code>, <code>reductuu</code>, <code>coooptuus</code> etc.</p>

<p>Puterea unei vrăji se calculează în funcție de numărul de vocale și de consoane pe care le are vraja, după formula: <code>[(nrv*V+nrc*C)/nrd]+1</code>, unde:</p>

<ul>
	<li><code>V</code> – puterea unei vocale;</li>
	<li><code>C</code> – puterea unei consoane;</li>
	<li><code>nrv</code> – numărul de vocale din vrajă;</li>
	<li><code>nrc</code> – numărul de consoane din vrajă;</li>
	<li><code>nrd</code> – numărul de litere distincte din vrajă;</li>
	<li><code>[a]</code> – reprezintă partea întreagă a numărului a.</li>
</ul>

<p>Se vor considera vocale: <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>q</code>, <code>w</code>, <code>y</code>.</p>

<p>Se numeşte grup o secvenţă de cel puţin două litere identice. Un grup se numeşte maximal, dacă este delimitat de litere diferite de conţinutul său, respectiv de începutul sau sfârşitul vrăjii.<br>
Spre exemplu: în vraja <code>coooptuus</code>, <code>ooo</code> și <code>uu</code> sunt grupuri maximale, însă <code>oo</code> nu este grup maximal. </p>

<p>Deoarece Harry este un vrăjitor special, acesta are abilitatea de a calcula puterea fiecărui grup maximal dintr-o vrajă, și apoi să o adune la puterea acesteia. Puterea unui grup se obține înmulțind puterea literei respective cu ea însăși de același număr de ori câte litere identice are grupul.<br>
Exemple: pentru <code>V=5</code> și <code>C=2</code>,	 <code>stupefy</code> are puterea <code>[(3*5+4*2)/7)]+1=3+1=4</code>;<br>
<code>accio</code> are puterea <code>[(3*5+2*2)/4]+1+2*2=4+1+4=9</code>;<br>
<code>reductuu</code> are puterea <code>[(4*5+4*2)/6]+1+5*5=4+1+25=30</code>.</p>

<p>După lovitura primită, Harry mai știe doar <code>N</code> vrăji.<br>
Se numește vrajă specială o vrajă pe care Harry își poate folosi abilitatea specială. <br>
Exemple: <code>accio</code> și <code>reductuu</code> sunt vrăji speciale, deoarece au fiecare cel puțin un grup maximal de două litere identice;<br>
<code>stupefy</code> nu este o vrajă specială deoarece nu are are niciun grup de litere identice.</p>

<h1>Cerința</h1>

<p>Cunoscând <code>N</code>, <code>V</code>, <code>C</code> și vrăjile pe care le mai știe Harry, se cere:</p>

<p>a)numărul total de vrăji speciale;<br>
b)prima vrajă de putere maximă pe care Harry şi-o aminteşte, și câte astfel de vrăji poate folosi eroul nostru.</p>

<h1>Date de intrare</h1>

<p>Fişierul de intrare <code>vraji.in</code> conţine pe prima linie un număr natural <code>p</code>. Pentru toate testele de intrare, numărul <code>p</code> poate avea doar valoarea <code>1</code> sau valoarea  <code>2</code>. Următoarea linie conţine <code>3</code> numere întregi separate prin spațiu: <code>N</code>, <code>V</code> și <code>C</code> în această ordine. Pe următoarele <code>N</code> linii se vor găsi vrăjile pe care Harry le mai știe, fiecare vrajă pe câte o linie (în ordinea în care el și le aduce aminte).</p>

<h1>Date de ieșire</h1>

<p>Dacă valoarea lui <code>p</code> este <code>1</code>, <strong>se va rezolva numai punctul a)</strong> din cerință. </p>

<p>În acest caz, în fişierul de ieşire <code>vraji.out</code> se va scrie un singur număr natural reprezentând numărul total de vrăji speciale.</p>

<p>Dacă valoarea lui <code>p</code> este <code>2</code>, <strong>se va rezolva numai punctul b)</strong> din cerință. </p>

<p>În acest caz, fişierul de ieşire <code>vraji.out</code> va conține numărul de vrăji de putere maximă urmat de prima vrajă de putere maximă pe care și-o mai amintește Harry, separate printr-un spațiu.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>-50 ≤ V, C ≤ 50</code></li>
	<li><code>1 ≤ N ≤ 50 000</code></li>
	<li>Lungimea unei vrăji ≤ <code>50</code></li>
	<li>Se garantează că valoarea puterii unei vrăji pentru toate testele este ≤ <code>2 147 483 647</code>.</li>
	<li>Pentru rezolvarea corectă a primei cerinţe se acordă 20 de puncte, iar pentru cerința a doua se acordă 80 de puncte.</li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>vraji.in</code></p>

<pre contenteditable="true" editable="true">1
6 5 2
stupefy
accio
expelliarmus
depulso
levicorpus
reductuu</pre>

<p><code>vraji.out</code></p>

<pre contenteditable="true" editable="true">3</pre>

<h1>Explicație</h1>

<p><code>p = 1</code></p>

<p>Sunt <code>3</code> vrăji speciale: <code>accio</code>, <code>expelliarmus</code>, <code>reductuu</code>, deoarece acestea au grupuri de litere vecine identice.</p>

<p><strong>Atenție! Pentru acest test se rezolvă doar cerința a).</strong></p>



<h1>Exemplul 2:</h1>

<p><code>vraji.in</code></p>

<pre contenteditable="true" editable="true">2
6 5 2
stupefy
accio
expelliarmus
depulso
levicorpus
reductuu</pre>

<p><code>vraji.out</code></p>

<pre contenteditable="true" editable="true">1 reductuu</pre>

<h1>Explicație</h1>

<p><code>p = 2</code></p>

<p></p>

<p><strong>Atenție! Pentru acest test se rezolvă doar cerința b).</strong></p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <cstring>
using namespace std;
ifstream cin("vraji.in");
ofstream cout("vraji.out");
int n , v , c , cer , cnt , cate , maxi;
char vmax[51];
int put(int x , int y)
{
    int p = 1;
    for(int i = 1 ; i <= y ; i++)
        p *= x;
    return p;
}
int vocala(char a)
{
    return a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u' || a == 'q' || a == 'w' || a == 'y';
}
int consoana(char a)
{
    if(a >= 'a' &amp;&amp; a <= 'z' &amp;&amp; !vocala(a)) return 1;
    else return 0;
}

int calcul(char s[])
{
    int i = 0;
    int catevoc = 0 , catecons = 0 , f[30] = {0} , suma = 0 , dist = 0;
    while(s[i] != '\0')
    {
        if(vocala(s[i])) catevoc++;
        if(consoana(s[i])) catecons++;
        f[s[i] - 'a']++;
        i++;
    }
    for(int j = 0 ; j <= 25 ; j++)
    {
        if(f[j]) dist++;
    }
    //cout << dist <<'\n';
    suma = (catevoc * v + catecons * c) / dist + 1;
    i = 0;
    int l = 0;
    while(s[i] != '\0')
    {
        if(s[i] == s[i+1])
        {
            l = 1;
            int j = i;
            while(s[i] == s[j])
            {
                j++ , l++;
            }
            if(l > 1 &amp;&amp; vocala(s[i])) suma += put(v , l - 1);
            else if(l > 1 &amp;&amp; consoana(s[i])) suma += put(c , l - 1);
            i = j - 1;
        }
        i++;
        //cout << s[i] << " ";
    }
    return suma;
}
int main()
{
    char s[51];
    cin >> cer;
    cin >> n >> v >> c;
    for(int i = 1 ; i <= n ; i++)
    {
        cin >> s;
        int j = 0 , ok = 0;
        while(s[j] != '\0')
        {
            if(s[j] == s[j-1]) ok = 1;
            j++;
        }
        if(ok == 1) cnt++;
        if(calcul(s) > maxi)
        {
            maxi = calcul(s);
            cate = 1;
            strcpy(vmax , s);
        }
        else if(calcul(s) == maxi)
            cate++;
    }
    if(cer == 1) cout << cnt;
    else
    {
        cout << cate << " " << vmax;
    }
}</pre>
