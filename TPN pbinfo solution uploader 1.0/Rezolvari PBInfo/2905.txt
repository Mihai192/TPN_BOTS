<h1>Cerința</h1>

<p>Gigel a găsit un șir cu <code>n</code> numere naturale, numerotate de la <code>1</code> la <code>n</code> și un număr <code>p</code>. Neavând chef de muncă, Gigel vă cere să rezolvați următoarele cerințe:</p>

<p>a) Aflați câți divizori are numărul din șir aflat pe poziția <code>p</code>.<br>
b) Afișați în ordine descrescătoare numerele din șir care au același număr de divizori ca cel aflat pe poziția <code>p</code>.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>divizori4.in</code> conține pe prima linie numerele <code>n c</code>, unde <code>c</code> poate fi doar <code>1</code> sau <code>2</code>. A doua linie conține cele <code>n</code> elemente ale șirului. A treia linie conține numărul <code>p</code>.</p>

<h1>Date de ieșire</h1>

<p>Dacă <code>c=1</code> se rezolvă numai cerința a). Fișierul de ieșire <code>divizori4.out</code> va conține pe prima linie numărul de divizori ai numărului aflat în șir pe poziția <code>p</code>.</p>

<p>Dacă <code>c=2</code> se rezolvă numai cerința b). Fișierul de ieșire <code>divizori4.out</code> va conține pe prima linie, în ordine descrescătoare, numerele din șir cu același număr de divizori ca și cel aflat pe poziția <code>p</code>.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li>numerele din șir vor fi numere naturale nenule mai mici sau egale cu <code>1.000.000.000</code></li>
	<li>pentru 50% din punctaj  <code>c=1</code>; pentru 50% din punctaj  <code>c=2</code>;</li>
	<li>pentru <code>c=1</code>, <code>1 ≤ p ≤ n ≤ 50.000</code></li>
	<li>pentru <code>c=2</code>, <code>1 ≤ p ≤ n ≤ 50.000</code> pentru 30% din punctaj și <code>1 ≤ p ≤ n ≤ 10.000</code> pentru 20% din punctaj</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>divizori4.in</code></p>

<pre contenteditable="true" editable="true">10 1
1 5 95 23 16 39 77 74 97 57 
3</pre>

<p><code>divizori4.out</code></p>

<pre contenteditable="true" editable="true">4</pre>

<h3>Explicație</h3>

<p><code>c=1</code>, se rezolvă doar cerința a). Al treilea număr din șir este <code>95</code>, care are <code>4</code> divizori (<code>1 5 19 95</code>).</p>


<h1>Exemplul 2</h1>

<p><code>divizori4.in</code></p>

<pre contenteditable="true" editable="true">10 2
1 5 95 23 16 39 77 74 97 57 
3</pre>

<p><code>divizori4.out</code></p>

<pre contenteditable="true" editable="true">95 77 74 57 39 </pre>

<h3>Explicație</h3>

<p><code>c=2</code>, se rezolvă doar cerința b). Al treilea număr din șir este <code>95</code>, care are <code>4</code> divizori. Numerele cu <code>4</code> divizori din șir sunt, în ordine descrescătoare: <code>95 77 74 57 39</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <algorithm>
 
using namespace std;
 
ifstream fin("divizori4.in");
ofstream fout("divizori4.out");
 
int P[200000],np;
bool E[1000001];
 
void ciur(bool E[], int n)
{//ciurul lui Eratostene
    for(int i=2;i<=n;i++) E[i]=1;
    for(int i=2;i*i<=n;i++)
        if(E[i]==1)
            for(int j=i*i;j<=n;j=j+i)
                E[j]=0;
}
 
void prime(int n, int P[], int &amp;np)
{//numerele prime pana la n
    np=0;
    for(int i=2;i<=n;i++)
        if(E[i]==1) P[++np]=i;
}
 
int nrdiv(int n)
{
    int d=1,c=1;
    while(n>1)
    {
        if(n%P[d]==0)
        {
            int p = 0;
            while(n%P[d]==0) n=n/P[d], ++p;
            c*=(p+1);
        }
        else ++d;
        if(n>1 &amp;&amp; P[d]*P[d]>n)
        {
            return 2*c;
        }
    }
    return c;
}
 
int v[50001];
 
int main()
{
    ios::sync_with_stdio(false);
    ciur(E,1000001);
    prime(1000001,P,np);
    int n, c, p;
    fin>>n>>c;
    for(int i=1;i<=n;++i)
        fin>>v[i];
    fin>>p;
    if(c==1) {fout<<nrdiv(v[p]); return 0;}
    else{
        int nd = nrdiv(v[p]);
        sort(v+1, v+n+1);
        for(int i=n;i>0;--i)
            if(nrdiv(v[i]) == nd) fout<<v[i]<<' ';
    }
    return 0;
}</pre>
