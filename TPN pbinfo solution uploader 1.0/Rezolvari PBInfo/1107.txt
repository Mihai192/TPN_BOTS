<p>La un concurs de robotică, în timpul prezentării, un roboţel cu corp cilindric cu diametrul de o unitate scapă de sub control şi se deplasează într-un ring de formă dreptunghiulară. Ringul este împărţit în <code>N x M</code> pătrate identice, cu latura de o unitate, aşezate pe <code>N</code> linii şi <code>M</code> coloane. </p>

<p><img align="right" alt="" height="140" src="/resurse/9dc152/p-1100/reflex1.png" width="255"> Robotul poate părăsi ringul numai pe la colţuri, acestea fiind numerotate de la <code>1</code> la <code>4</code>, colţul cu numărul <code>1</code> fiind cel din stânga jos apoi restul fiind numerotate în sens trigonometric. Suprafaţa ringului este delimitată de exterior prin intermediul a patru pereţi despărţitori: doi pereţi “verticali” (aşezaţi de la colţul <code>1</code> la colţul <code>4</code>, respectiv de la colţul <code>2</code> la colţul <code>3</code>) şi doi pereţi “orizontali” (aşezaţi de la colţul <code>1</code> la colţul <code>2</code>, respectiv de la colţul <code>3</code> la colţul <code>4</code>), fără a bloca ieşirile, ca în desenul alăturat.</p>

 Robotul pătrunde în ring prin colţul cu numărul <code>1</code> sub un unghi de <code>45</code> grade şi cu o viteză de un pătrat/s. Ciocnirile cu pereţii sunt considerate perfect elastice (robotul nu-şi pierde din viteză) iar unghiul de incidenţă este egal cu cel de reflexie.

<h1>Cerinţe</h1>

<p>Se cere să se determine:</p>

<p>a) după câte secunde şi prin ce colţ al ringului va ieşi robotul;<br>
b) de câte ori se ciocneşte robotul de pereţii orizontali şi verticali, rezultând o schimbare de direcţie, până la ieşirea din ring.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>reflex.in</code> conține pe prima linie două numere naturale <code>N</code> şi <code>M</code>, separate printr-un singur spaţiu.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>reflex.out</code> va conține pe prima linie două numere naturale <code>S</code> și <code>C</code>, separate printr-un singur spațiu, <code>S</code> reprezentând numărul de secunde după care robotul va ieşi din ring, iar <code>C</code> reprezintă numărul colţului prin care acesta va ieşi. Pe a doua linie, fişierul de ieşire va conține două numere naturale <code>H</code> şi <code>V</code>, separate printr-un  spaţiu, <code>H</code> reprezentând numărul de ciocniri cu pereţii orizontali ai ringului, iar <code>V</code> numărul de ciocniri cu pereţii verticali.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>3 ≤ N, M ≤ 2 000 000 000</code></li>
	<li>Pentru rezolvarea corectă a unei singure cerinţe se acordă 50% din punctaj, iar pentru rezolvarea corectă a  ambelor cerinţe se acordă 100% din punctaj.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>reflex.in</code></p>

<pre contenteditable="true" editable="true">3 6</pre>

<p><code>reflex.out</code></p>

<pre contenteditable="true" editable="true">11 4
4 1</pre>

<h1>Explicație</h1>

<p><img alt="" height="130" src="/resurse/9dc152/p-1100/reflex3.png" width="218"></p>

<p>Până la ieşire se parcurg 11 pătrate, ieşirea se produce pe la colţul <code>4</code>. Se produc <code>4</code> ciocniri cu pereţii orizontali şi o ciocnire cu pereţii verticali.</p>

<h1>Exemplul 2</h1>

<p><code>reflex.in</code></p>

<pre contenteditable="true" editable="true">5 7</pre>

<p><code>reflex.out</code></p>

<pre contenteditable="true" editable="true">13 4
2 1</pre>

<h1>Explicație</h1>

<p><img alt="" height="164" src="/resurse/9dc152/p-1100/reflex4.png" width="222"></p>

<p>Se parcurg <code>13</code> pătrate, ieşirea se face la colţul <code>4</code> şi de produc <code>2</code> ciocniri cu pereţii orizontali (în punctele <code>a</code> şi <code>c</code> respectiv o ciocnire cu pereţii verticali în punctul <code>b</code>).</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include<fstream>
using namespace std;
ifstream cin("reflex.in");
ofstream cout("reflex.out");
long long a , b , s , c , x , y , r , a1 , b1;
int colt[3]={2 , 4 , 3};

int main()
{
    cin >> a >> b;
    a1 = a-1;
    b1 = b-1;
    while(b1!=0){r = a1 % b1; a1 = b1; b1 = r;}
    x = (b - 1) / a1;
    y = (a - 1) / a1;
    c = colt[y % 2 + (x % 2)*2 - 1];
    s = y * (b - 1);
    cout << s + 1 << " " << c << '\n' << x - 1 << " " << y - 1;
    return 0;
}</pre>
