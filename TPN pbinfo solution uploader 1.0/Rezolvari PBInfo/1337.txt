<h1>Cerința</h1>

<p>Eroul nostru Susan se află într-un turn de formă cubică, de latură <code>n</code>. El dorește să ajungă la comoara ascunsă în interiorul turnului. Din fericire, Susan a făcut rost de o hartă care îi indică cu exactitate coordonatele locului în care se află comoara din turn. Eroul nostru vrea să știe care este distanța minimă pe care o poate parcurge pentru a ajunge la comoară.</p>

Turnul este împărțit în <code>n</code> etaje, iar fiecare etaj este împărțit în <code>n x n</code> celule (camere). O cameră poate:
<ul>
	<li>fi <b>blocată</b>, astfel fiind inaccesibilă eroului nostru</li>
	<li>fi <b>accesibilă</b>, astfel eroul nostru poate intra în aceasta</li>
	<li>conține o <b>scară ascendentă</b> care îl poate duce pe erou cu un etaj mai sus, în camera situată deasupra camerei curente</li>
	<li>conține o <b>scară descendentă</b> care îl poate duce pe erou cu un etaj mai jos, în camera situată sub camera curentă</li>
	<li>conține o <b>trapă</b> prin care eroul va cădea la etajul inferior, în camerele situate sub camera curentă (dacă eroul, în urma căderii, se află într-o cameră ce conține o trapă, el va continua să cadă până se va afla într-o o cameră fără trapă, pe aceeași coloană)</li>
</ul>

<p>La fiecare trecere dintr-o cameră în alta, eroul execută un pas.</p>

<p>Fiind date latura turnului și coordonatele zidurilor, scărilor, gropilor, eroului și a comorii, se cere să se afișeze numărul minim de pași pe care îl poate parcurge Susan pentru a ajunge la comoară.</p>


<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>turn.in</code> conține:<br>
</p><ul>
	<li>pe prima linie numărul <code>n</code>, reprezentând lungimea laturii turnului.</li>
	<li>pe a doua linie se află numărul <code>z</code>, reprezentând numărul de ziduri, numărul <code>s1</code>, reprezentând numărul de scări descendente, numărul <code>s2</code>, reprezentând numărul de scări descendente și numărul <code>g</code>, reprezentând numărul de gropi.</li>
	<li>pe următoarele <code>z</code> linii se află coordonatele zidurilor.</li>
	<li>pe următoarele <code>s1</code> linii se află coordonatele scărilor ascendente.</li>
	<li>pe următoarele <code>s2</code> linii se află coordonatele scărilor descendente.</li>
	<li>pe următoarele <code>g</code> linii se află coordonatele gropilor.</li>
	<li>pe penultima linie se află coordonatele eroului, iar pe ultima linie se află coordonatele comorii.</li><br>
</ul><p></p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>turn.out</code> va conține numărul minim de pași pe care îl poate face Susan pentru a ajunge la comoara sa.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ n ≤ 100</code></li>
	<li><code>1 ≤ z ≤ 30000</code></li>
	<li><code>1 ≤ s1 ≤ s2 ≤ 200</code></li>
	<li><code>1 ≤ g ≤ 10000</code></li>
	<li>Se garantează că există soluție pentru toate datele de test.</li>
	<li>Poziția inițială se consideră a fi situată la pasul 1.</li>
	<li>Trapa generează o cădere a eroului pe verticală, până când ajunge într-o cameră fără trapă.</li>
</ul>

<br><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- link-unit -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:15px" data-ad-client="ca-pub-7152921241438800" data-ad-slot="6421896419" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0;width:728px;height:15px;" sandbox="allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="728" height="15" frameborder="0" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-7152921241438800&amp;output=html&amp;h=15&amp;slotname=6421896419&amp;adk=1130877403&amp;adf=3283908322&amp;w=728&amp;lmt=1595356541&amp;psa=1&amp;guci=1.2.0.0.2.2.0.0&amp;url=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F1337%2Fsusan&amp;flash=0&amp;wgl=1&amp;dt=1595356541418&amp;bpp=47&amp;bdt=552&amp;idt=242&amp;shv=r20200716&amp;cbv=r20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;prev_fmts=336x280%2C0x0&amp;nras=1&amp;correlator=1935144473097&amp;frm=20&amp;pv=1&amp;ga_vid=704522989.1595356494&amp;ga_sid=1595356541&amp;ga_hid=357448254&amp;ga_fc=0&amp;iag=0&amp;icsg=17380323360767&amp;dssz=47&amp;mdo=0&amp;mso=0&amp;u_tz=180&amp;u_his=11&amp;u_java=0&amp;u_h=900&amp;u_w=1440&amp;u_ah=816&amp;u_aw=1440&amp;u_cd=30&amp;u_nplug=3&amp;u_nmime=4&amp;adx=41&amp;ady=1744&amp;biw=1200&amp;bih=649&amp;scr_x=0&amp;scr_y=0&amp;oid=3&amp;pvsid=3238416793674062&amp;pem=564&amp;ref=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F1856%2Ftaxe2&amp;rx=0&amp;eae=0&amp;fc=896&amp;brdim=22%2C45%2C22%2C45%2C1440%2C23%2C1200%2C772%2C1200%2C649&amp;vis=1&amp;rsz=%7Co%7CeEbr%7C&amp;abl=NS&amp;pfx=0&amp;fu=8192&amp;bc=31&amp;ifi=2&amp;uci=a!2&amp;btvi=2&amp;fsb=1&amp;xpc=RV70IqLzoX&amp;p=https%3A//www.pbinfo.ro&amp;dtd=248" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" data-google-container-id="a!2" data-load-complete="true" data-google-query-id="CLfM1p_-3uoCFQSHsgodafIEbw"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1>Exemplu</h1>

<p><code>turn.in</code></p>

<pre contenteditable="true" editable="true">3
9 3 3 3
1 1 3
1 2 1
1 3 2
2 1 1
2 1 3
2 2 2
3 1 1
3 2 3
3 3 3
1 2 3
2 3 2
2 1 2
2 2 3
3 3 2
3 1 2
3 3 1
3 2 1
2 3 1
1 1 1
2 2 1</pre>


<p><code>turn.out</code></p>

<pre contenteditable="true" editable="true">11</pre>

<h3>Explicație</h3>

<p>Turnul are <code>3</code> etaje. Susan pleacă din celula de coordonate <code>(1 1 1)</code>, iar celula în care se află comoara are coordonatele <code>(2 2 1)</code>. Există <code>9</code> celule în care se află ziduri, <code>3</code> celule în care se află scări ascendente, <code>3</code> celule în care se află scări descendente și <code>3</code> celule în care se află gropi. Traseul cel mai scurt trece prin <code>11</code> camere: <code>(1 1 1) (1 1 2) (1 2 2) (1 2 3) (2 2 3) (2 3 3) (2 3 2) (3 3 2) (3 2 2) (3 2 1) (2 2 1)</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <queue>
using namespace std;

ifstream cin("turn.in");
ofstream cout("turn.out");

struct poz
{
    int i , j , k;
};

const int dj[] = {-1 , 1 ,  0 , 0};
const int dk[] = { 0 , 0 , -1 , 1};

int n , x1 , y1 , z1 , x2 , y2 , z2 , m , p , qu , r;
int a[101][101][101];
int b[101][101][101];

queue < poz > q;

int inside(int i , int j , int k)
{
    return i >= 1 &amp;&amp; i <= n &amp;&amp; j >= 1 &amp;&amp; j <= n &amp;&amp; k >= 1 &amp;&amp; k <= n;
}

void lee()
{
    b[x1][y1][z1]=1;
    poz r;
    r.i = x1 , r.j = y1 , r.k = z1;
    while(!q.empty())
    {
        poz r;
        r = q.front();
        if(a[r.i][r.j][r.k] == -4)
        {
            int inou = r.i;
            if(a[inou][r.j][r.k] == -4 &amp;&amp; inou > 1) inou--;
            if(inside(inou , r.j , r.k) &amp;&amp; a[inou][r.j][r.k] != -1 &amp;&amp; b[inou][r.j][r.k] == 0)
            {
                q.push({inou , r.j , r.k});
                b[inou][r.j][r.k] = b[r.i][r.j][r.k] + 1;
            }
        }
        else
        {
            if(a[r.i][r.j][r.k] == -2)
            {
                int inou = r.i + 1;
                if(inside(inou , r.j , r.k) &amp;&amp; a[inou][r.j][r.k] != -1 &amp;&amp; b[inou][r.j][r.k] == 0)
                {
                    q.push({inou , r.j , r.k});
                    b[inou][r.j][r.k] = b[r.i][r.j][r.k] + 1;
                }
            }
            else if(a[r.i][r.j][r.k] == -3)
            {
                int inou = r.i - 1;
                if(inside(inou , r.j , r.k) &amp;&amp; a[inou][r.j][r.k] != -1 &amp;&amp; b[inou][r.j][r.k] == 0)
                {
                    q.push({inou , r.j , r.k});
                    b[inou][r.j][r.k] = b[r.i][r.j][r.k] + 1;
                }
            }
            for(int d = 0 ; d < 4 ; d++)
                {
                    int inou = r.i;
                    int jnou = r.j + dj[d];
                    int knou = r.k + dk[d];
                    if(inside(inou , jnou , knou) &amp;&amp; a[inou][jnou][knou] != -1 &amp;&amp; b[inou][jnou][knou] == 0)
                    {
                        q.push({inou , jnou , knou});
                        b[inou][jnou][knou] = b[r.i][r.j][r.k] + 1;
                    }
                }
        }
        q.pop();
    }
}

int main()
{
    cin >> n >> m >> p >> qu >> r;
    int x,y,z;
    for(int i = 1 ; i <= m ; i++)
    {
        cin >> x >> y >> z;
        a[x][y][z] = -1;
    }
    for(int i = 1 ; i <= p ; i++)
    {
        cin >> x >> y >> z;
        a[x][y][z] = -2;
    }
    for(int i = 1 ; i <= qu ; i++)
    {
        cin >> x >> y >> z;
        a[x][y][z] = -3;
    }
    for(int i = 1 ; i <= r ; i++)
    {
        cin >> x >> y >> z;
        a[x][y][z] = -4;
    }
    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;
    q.push({x1 , y1 , z1});
    lee();
    cout << b[x2][y2][z2];
    return 0;
}</pre>
