<p>Un copil construiește un triunghi cu numerele naturale nenule astfel:</p>

<ul>
	<li>în vârful triunghiului scrie valoarea <code>1</code>;</li>
	<li>completează liniile triunghiului de sus în jos, iar căsuțele de pe aceeași linie de la stânga la dreapta cu numere naturale consecutive, ca în figurile următoare.</li>
</ul>

<p><img alt="" src="/resurse/9dc152/p-1700/2007-numere.jpg"></p>

<p>În figura 1 este ilustrat un astfel de triunghi având <code>5</code> linii, conținând numerele naturale de la <code>1</code> la <code>15</code>.<br>
În acest triunghi copilul începe să construiască drumuri, respectând următoarele reguli:</p>

<ul>
	<li>orice drum începe din <code>1</code>;</li>
	<li>din orice căsuță se poate deplasa fie în căsuța situată pe linia următoare în stânga sa (deplasare codificată cu <code>1</code>), fie în căsuța situată pe linia următoare în dreapta sa (deplasare codificată cu <code>2</code>);</li>
	<li>orice drum va fi descris prin succesiunea deplasărilor efectuate.</li>
</ul>

<p>De exemplu, drumul ilustrat în figura 2 poate fi descris astfel: <code>1 2 2 2</code>.</p>

<h1>Cerința</h1>

<p>Scrieţi un program care rezolvă următoarele două cerințe:</p>

<p>1. citește descrierea unui drum și afișează numărul la care se termină drumul;<br>
2. citește un număr natural nenul K, determină un drum care se termină cu numărul K pentru care suma numerelor prin care trece drumul este maximă și afișează această sumă.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>numere17.in</code> conține pe prima linie un număr natural <code>C</code> reprezentând cerința din problemă care trebuie rezolvată (1 sau 2).</p>

<p>Dacă <code>C</code> este egal cu <code>1</code>, a doua linie din fișier conține un număr natural <code>N</code>, reprezentând lungimea drumului, iar a treia linie din fișier conţine descrierea drumului sub forma a <code>N</code> valori, <code>1</code> sau <code>2</code>, separate între ele prin câte un spațiu.</p>

<p>Dacă <code>C</code> este egal cu <code>2</code>, a doua linie din fișier conține numărul natural <code>K</code>.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>numere17.out</code> va conține o singură linie pe care va fi scris un singur număr natural. Dacă <code>C=1</code>, va fi scris numărul cu care se termină drumul descris în fișierul de intrare. Dacă <code>C=2</code>, va fi scrisă suma maximă a numerelor aflate pe un drum care se termină cu numărul <code>K</code>.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ n ≤ 10000</code></li>
	<li><code>1 ≤ K ≤ 10001*10002/2</code></li>
	<li>Pentru rezolvarea corectă a cerinţei 1 se acordă 40 de puncte; pentru rezolvarea corectă a cerinței 2 se acordă 50 de puncte. În concurs s-au acordat 10 puncte din oficiu. Pe site se acordă 10 puncte pentru exemple.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>numere17.in</code></p>

<pre contenteditable="true" editable="true">1 
4
1 2 1 2</pre>

<p><code>numere17.out</code></p>

<pre contenteditable="true" editable="true">13</pre>

<h3>Explicație</h3>

<p>Cerinţa este 1. Drumul descris are lungimea <code>4</code> și trece prin numerele <code>1,2,5,8,13</code></p>

<h1>Exemplul 2</h1>

<p><code>numere17.in</code></p>

<pre contenteditable="true" editable="true">2 
9</pre>

<p><code>numere17.out</code></p>

<pre contenteditable="true" editable="true">19</pre>

<h3>Explicație</h3>

<p>Cerinţa este 2. Suma maximă se obține pe drumul care trece prin numerele <code>1,3,6,9</code> (<code>1+3+6+9=19</code>).</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;
ifstream fin("numere17.in");
ofstream fout("numere17.out");
int main()
{
    int n , c , k , x , cnt = 0 , m = 1;
    fin >> c;
    if (c == 1)
    {
        fin >> n;
        for (int i = 1; i <= n ; ++i)
        {
            fin >> x;
            cnt++;
            if (x == 1) m += cnt;
            if (x == 2) m += cnt+1;
        }
        fout << m;
    }
    else
    {
        fin >> k;
        int x = 1 , s = 0 , maxi = 0;
        while (maxi < k)
        {
            maxi = maxi + x;
            s += maxi;
            x++;
        }
        s = s -(maxi - k) * (maxi - k + 1) / 2;
        fout << s;
    }
    return 0;
}</pre>
