<p>O tablă de șah de dimensiune <code>n x n</code> conține pe toate pătrățelele câte o piesă cu una din culorile: alb, negru, roșu, verde sau albastru. Pe tablă nu există <code>3</code> piese consecutive pe aceeași linie sau coloană de aceeași culoare. O mutare presupune interschimbarea a două piese alăturate, fie pe o linie, fie pe o coloană. După mutare se acordă punctaj dacă se obțin următoarele situații și nu numai:</p>

<ul>
	<li><code>3</code> piese de aceeași culoare consecutive pe o linie sau o coloană <code>= 1</code> punct;</li>
	<li><code>3</code> piese de aceeași culoare consecutive pe o linie și o coloană <code>= 5</code> puncte;</li>
</ul>

<p>La orice situație de mai sus, o piesă în plus de aceeași culoare mai contribuie cu încă <code>1</code> la punctaj. De exemplu, <code>4</code> piese de aceeași culoare consecutive pe o linie sau o coloană <code>= 2</code> puncte. Punctajele obținute de piesele interschimbate se adună. Punctajul este <code>0</code> dacă nu se obțin măcar <code>3</code> piese consecutive de aceeași culoare.</p>

<h1>Cerința</h1>

<p>Găsiți cel mai mare punctaj obținut în urma unei singure mutări.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>tabla.in</code> conține, pe prima linie, numărul natural <code>n</code>, ce reprezintă dimensiunea tablei. Pe fiecare dintre următoarele <code>n</code> linii se află câte <code>n</code> valori separate prin spatii. Valorile posibile pot fi: <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> și <code>5</code>. Valoarea <code>1</code> reprezintă piesa de culoare albă, <code>2</code> piesa de culoare neagră etc.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>tabla.out</code> va conține cel mai mare punctaj obținut.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ n ≤ 20</code></li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>tabla.in</code></p>

<pre contenteditable="true" editable="true">3
1 1 2
2 2 1
3 4 5</pre>

<p><code>tabla.out</code></p>

<pre contenteditable="true" editable="true">2</pre>

<h3>Explicație</h3>

<p>Prin interschimbarea elementului <code>(1,3)</code> cu <code>(2,3)</code> se obține:<br>
<code>1 1 1</code><br>
<code>2 2 2</code><br>
<code>3 4 5</code><br>
și am <code>1</code> punct din prima linie și <code>1</code> punct din a doua linie</p>

<h1>Exemplul 2:</h1>

<p><code>tabla.in</code></p>

<pre contenteditable="true" editable="true">6
1 2 4 2 1 5
1 2 4 2 4 4
4 4 3 4 4 1
3 3 4 3 3 5
1 1 3 1 1 2
1 1 3 1 1 2</pre>

<p><code>tabla.out</code></p>

<pre contenteditable="true" editable="true">14</pre>

<h3>Explicație</h3>

<p>Prin interschimbarea elementului <code>(3,3)</code> cu <code>(4,3)</code> se obține:<br>
<code>1 2 4 2 1 5</code><br>
<code>1 2 4 2 4 4</code><br>
<code>4 4 4 4 4 1</code><br>
<code>3 3 3 3 3 5</code><br>
<code>1 1 3 1 1 2</code><br>
<code>1 1 3 1 1 2</code><br>
și am <code>7</code> (<code>5+2</code>) puncte de la piesele codificate cu <code>4</code> și <code>7</code> puncte de la piesele codificate cu <code>3</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;

ifstream cin("tabla.in");
ofstream cout("tabla.out");

int a[21][21], n, cnt, b[21][21];

bool inmat(int i, int j)
{
    return i <= n &amp;&amp; j <= n &amp;&amp; i >= 1 &amp;&amp; j >= 1;
}

bool cont3pr(int i, int j){
    if(a[i][j] == a[i-1][j] &amp;&amp; a[i-1][j] == a[i-2][j] &amp;&amp; inmat(i-2, j))
        return 1;
    if(a[i][j] == a[i-1][j] &amp;&amp; a[i-1][j] == a[i+1][j] &amp;&amp; inmat(i-1,j) &amp;&amp; inmat(i+1, j))
        return 1;
    if(a[i][j] == a[i+1][j] &amp;&amp; a[i+1][j] == a[i+2][j] &amp;&amp; inmat(i+2, j))
        return 1;
    return 0;
}

bool cont3pl(int i, int j){
    if(a[i][j] == a[i][j+1] &amp;&amp; a[i][j+1] == a[i][j+2] &amp;&amp; inmat(i, j+2))
        return 1;
    if(a[i][j] == a[i][j-1] &amp;&amp; a[i][j-1] == a[i][j+1] &amp;&amp; inmat(i, j-1) &amp;&amp; inmat(i, j+1))
        return 1;
    if(a[i][j] == a[i][j-1] &amp;&amp; a[i][j-1] == a[i][j-2] &amp;&amp; inmat(i, j-2))
        return 1;
    return 0;
}

void transfB(int i, int j){
    if(a[i][j] == a[i-1][j] &amp;&amp; a[i-1][j] == a[i-2][j] &amp;&amp; inmat(i-2, j))
        b[i][j] = b[i-1][j] = b[i-2][j] = 1;
    else if(a[i][j] == a[i-1][j] &amp;&amp; a[i-1][j] == a[i+1][j] &amp;&amp; inmat(i+1, j) &amp;&amp; inmat(i-1, j))
        b[i][j] = b[i-1][j] = b[i+1][j] = 1;
    else if(a[i][j] == a[i+1][j] &amp;&amp; a[i+1][j] == a[i+2][j] &amp;&amp; inmat(i + 2, j))
        b[i][j] = b[i+1][j] = b[i+2][j] = 1;
    if(a[i][j] == a[i][j-1] &amp;&amp; a[i][j-1] == a[i][j-2] &amp;&amp; inmat(i, j-2))
        b[i][j] = b[i][j-1] = b[i][j-2] = 1;
    else if(a[i][j] == a[i][j+1] &amp;&amp; a[i][j+1] == a[i][j-1] &amp;&amp; inmat(i, j-1) &amp;&amp; inmat(i, j+1))
        b[i][j] = b[i][j+1] = b[i][j-1] = 1;
    else if(a[i][j] == a[i][j+1] &amp;&amp; a[i][j+1] == a[i][j+2] &amp;&amp; inmat(i, j+2))
        b[i][j] = b[i][j+1] = b[i][j+2] = 1;
}

bool ladr3(int i, int j){
    bool ok = false;
    if(a[i][j] == a[i][j-1] &amp;&amp; a[i][j-1] == a[i][j-2] &amp;&amp; inmat(i, j-2))
        ok = true;
    if(b[i][j] == b[i][j-1] &amp;&amp; b[i][j-1] == b[i][j-2] &amp;&amp; b[i][j] == 1 &amp;&amp; inmat(i, j-2))
        ok = false;
    return ok;
}

bool lasus3(int i, int j){
    bool ok = false;
    if(a[i][j] == a[i-1][j] &amp;&amp; a[i][j] == a[i-2][j] &amp;&amp; inmat(i-2, j))
        ok = true;
    if(b[i][j] == b[i-1][j] &amp;&amp; b[i][j] == b[i-2][j] &amp;&amp; b[i][j] == 1 &amp;&amp; inmat(i-2, j))
        ok = false;
    return ok;
}

void verif(int i, int j){
    if(cont3pr(i, j) &amp;&amp; cont3pl(i, j))
        cnt+=5, transfB(i, j);
    else if(ladr3(i, j))
        cnt++;
    else if(lasus3(i, j))
        cnt++;
}

int di[]={0,1,-1,0};
int dj[]={-1,0,0,1};

int main(){
    int max = 0;
    cin >> n;
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= n; ++j)
            cin >> a[i][j];
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= n; ++j){
                int k, t;
                for(int d = 0; d <= 3; ++d)
                    if(inmat(i + di[d], j + dj[d])){
                        k = i + di[d], t = j + dj[d];
                        cnt = 0;
                        swap(a[i][j], a[k][t]);
                        for(int q = 1; q <= n; ++q)
                            for(int w = 1; w <= n; ++w)
                                verif(q,w);
                        if(cnt > max)
                            max = cnt;
                        swap(a[i][j], a[k][t]);
                        for(int q = 1; q <= n; ++q)
                            for(int w = 1; w <= n; ++w)
                                b[q][w] = 0;
                    }
            }
    cout << max;
    return 0;
}</pre>
