<p>Vrăjitoarea cea bună are un cufăr în care este închisă piatra magică de către piticii lăzii cu ajutorul unui cifru digital. Piticii i-au dat vrăjitoarei o cutie în care sunt <code>n</code> cartonașe. Pe fiecare cartonaș este scris un număr natural pe care vrăjitoarea îl va folosi să deschidă lada. Valorile scrise pe cartonașe sunt distincte între ele.<br>
Pentru a afla cifrul trebuie să procedeze astfel: extrage fiecare cartonaș din cutie și apoi determină valoarea magică asociată numărului natural scris pe cartonaș. Pentru fiecare cartonaș valoarea magică este dată de al <code>k</code>-lea divizor prim al numărului înscris pe acesta. Vrăjitoarea trebuie să adune valorile magice obținute pentru cele <code>n</code> cartonașe și apoi să introducă în ordine cifrele valorii obținute, pentru a descuia lada.</p>

<h1>Cerința</h1>

<p>Deoarece vrăjitoarea nu are timp la dispoziție vă roagă pe voi să o ajutați să rezolve următoarele probleme:<br>
1. Să afle valoarea magică pentru un cartonaș dat;<br>
2. Să afle cifrul cufărului.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare este <code>cufar.in</code>. Pe prima linie a fișierului de intrare se găsesc o valoare <code>p</code> care poate fi doar <code>1</code> sau <code>2</code> și numărul <code>n</code> de cartonașe despărțite prin câte un spațiu.<br>
Dacă <code>p</code> este <code>1</code> pe linia a doua a fișierului de intrare se găsesc două valori reprezentând numărul de pe cartonașul dat și valoarea <code>k</code>, separate printr-un spațiu, cu semnificația de mai sus.<br>
Dacă <code>p</code> este <code>2</code> pe următoarele <code>n</code> linii ale fișierului de intrare se găsesc câte două valori, separate prin câte un spațiu, reprezentând numărul de pe cartonaș și valoarea lui <code>k</code> pentru fiecare din cele <code>n</code> cartonașe.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire este <code>cufar.out</code>. Dacă valoarea lui <code>p</code> este <code>1</code>, atunci se va rezolva doar cerința <code>1</code> și fișierul de ieșire va conține pe prima linie valoarea magică asociată cartonașului dat.<br>
Dacă valoarea lui <code>p</code> este <code>2</code>, atunci se va rezolva doar cerința <code>2</code> și fișierul de ieșire va conține pe prima linie cifrul necesar deschiderii cufărului.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ n &lt; 1 000 000</code></li>
	<li><code>2 ≤ valoarea înscrisă pe un cartonaș ≤ 1 000 000</code></li>
	<li>Se garantează că pentru fiecare pereche <code>(număr, k)</code>, <code>număr</code> are cel puțin <code>k</code> divizori primi.</li>
	<li>Pentru rezolvarea corectă a cerinței <code>1</code> se acordă <code>18</code> puncte</li>
	<li>Pentru rezolvarea corectă a cerinței <code>2</code> se acordă <code>72</code> de puncte</li>
	<li>Pentru rezultate corecte la cerința a doua respectând restricțiile problemei și <code>n ≤ 1000</code> se acordă <code>18</code> puncte</li>
	<li>Pentru rezultate corecte la cerința a doua respectând restricțiile problemei și <code>n ≤ 500 000</code> se acordă <code>43</code> de puncte</li>
	<li>În concurs s-au acordat <code>10</code> puncte din oficiu. Aici se acordă pentru exemplele din enunț.</li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>cufar.in</code></p>

<pre contenteditable="true" editable="true">1 1
30 3</pre>

<p><code>cufar.out</code></p>

<pre contenteditable="true" editable="true">5</pre>

<h3>Explicație</h3>

<p><code>p = 1</code>, <code>n = 1</code><br>
Se rezolvă doar prima cerință. Al treilea divizor prim al numărului <code>30</code> este <code>5</code>.</p>

<h1>Exemplul 2:</h1>

<p><code>cufar.in</code></p>

<pre contenteditable="true" editable="true">2 5
30 3
64 1
105 2
1001 3
5474 4</pre>

<p><code>cufar.out</code></p>

<pre contenteditable="true" editable="true">48</pre>

<h3>Explicație</h3>

<p><code>p = 2</code>, <code>n = 5</code><br>
Se rezolvă doar a doua cerință. Al treilea divizor prim al numărului <code>30</code> este <code>5</code>.<br>
Primul divizor prim al numărului <code>64</code> este <code>2</code>.<br>
Al doilea divizor prim al numărului <code>105</code> este <code>5</code>.<br>
Al treilea divizor prim al numărului <code>1001</code> este <code>13</code>.<br>
Al patrulea divizor prim al numărului <code>5474</code> este <code>23</code>.<br>
Suma căutată va fi <code>S = 5 + 2 + 5 + 13 + 23</code>, de unde rezultă cifrul <code>48</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;
ifstream fin("cufar.in");
ofstream fout("cufar.out");

int P[200000] , np;
bool E[1000001];

void ciur(bool E[] , int n)
{
    //ciurul lui Eratostene
    for(int i = 2 ; i <= n ; i++) E[i] = 1;
    for(int i = 2 ; i * i <= n ; i++)
        if(E[i] == 1)
            for(int j = i * i ; j <= n ; j = j + i)
                E[j] = 0;
}

void prime(int n , int P[], int &amp;np)
{
    //numerele prime pana la n
    np = 0;
    for(int i = 2 ; i <= n ; i++)
        if(E[i] == 1) P[++np] = i;
}

int  descnk(int n, int k)
{
    //al k-lea div prim al lui n (fara D)
    int d = 1 , l = 0;
    while(n > 1)
    {
        if(n % P[d] == 0)
        {
            l++;
            if(l == k) return P[d];
            while(n % P[d] == 0) n /= P[d];
        }
        else d++;
        if(n > 1 &amp;&amp; P[d] * P[d] > n)
            return n;
    }
    return 0;
}

int main()
{
    ciur(E,1000001);
    prime(1000001,P,np);
    int n , p , x , k;
    fin >> p >> n;
    if(p == 1)
    {
        fin >> x >> k;
        fout << descnk(x,k);
    }
    else
    {
        unsigned long long  s = 0;
        for(int i = 1 ; i <= n ; i++)
           {
               fin >> x >> k;
               s += descnk(x,k);
           }
        fout << s;
        }
    return 0;
}</pre>
