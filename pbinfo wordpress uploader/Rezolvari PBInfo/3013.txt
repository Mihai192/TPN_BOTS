<h1>Cerința</h1>

<p>Gigel dorește să instaleze  în grădină o ghirlandă cu <code>N</code> becuri colorate, numerotate de la <code>1</code> la <code>N</code>, care, din minut în minut, să se aprindă și să se stingă automat. Pentru a putea face aceasta el s-a gândit să asocieze fiecărui bec câte un număr,  în felul următor: la fiecare minut, un bec se va aprinde dacă prima cifră a numărului asociat lui este număr prim, altfel becul va fi stins. Numerele asociate becurilor, au o proprietate specială, din minut în minut, acestea își mută circular cifrele spre stânga, la fiecare permutare prima cifra a fiecărui număr, devine ultima. Toată ghirlanda se va stinge, la momentul în care, numărul asociat, cu cele mai multe cifre, ajunge, din nou, la valoarea inițială (în acest timp, la fiecare minut, celelalte numere efectuează permutări). </p>

<p>Scrieți un program care să determine: <br>
1. Câte becuri aprinse sunt în starea inițială; <br>
2. Care este numărul maxim de becuri care pot fi aprinse la un moment dat; <br>
3. Care este becul/becurile care se aprind de cele mai multe ori.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>becuri1.in</code> conține pe prima linie numărul <code>C</code>, ce reprezinta numărul cerinței, de pe cea de-a doua linie un număr natural <code>N</code> ce reprezintă numărul de becuri colorate, iar de pe următoarele <code>N</code> linii, câte un număr natural, ce reprezintă numărul asociat fiecărui bec, în ordinea crescătoare a numerelor de ordine.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>becuri1.out</code> dacă <code>C=1</code> va conține pe prima linie, valoarea cerută la cerința 1.  Dacă <code>C=2</code> va conține pe prima linie, valoarea cerută la cerința 2. Dacă <code>C=3</code> va conține pe prima linie, numerele de ordine (despărțite prin câte un spațiu) ale becurilor care se aprind de cele mai multe ori; afișarea se va face în ordinea crescătoare a numerelor de ordine atașate becurilor; dacă nu există astfel de becuri în ghirlandă, se va afișa <code>-1</code>.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ N ≤ 100</code></li>
	<li>numerele asociate becurilor sunt intre <code>0</code> și <code>1.000.000.000</code>. Pot exista mai multe becuri cu același număr asociat</li>
</ul>

<h1>Exemplul 1:</h1>

<p><code>becuri1.in</code></p>

<pre contenteditable="true" editable="true">1
5
12
5
378
2015
8</pre>

<p><code>becuri1.out</code></p>

<pre contenteditable="true" editable="true">3</pre>

<h3>Explicație</h3>

<p>Cerința 1. <br>
Gigel are o ghirlandă cu <code>5</code> becuri. Primul bec are asociat numărul <code>12</code> și este stins. Al doilea bec are asociat numărul <code>5</code> și este aprins. Al treilea bec are asociat numărul <code>378</code> și este aprins. Al patrulea bec are asociat numărul <code>2015</code> și este aprins. Al cincilea bec are asociat numărul <code>8</code> și este stins.</p>

<h1>Exemplul 2:</h1>

<p><code>becuri1.in</code></p>

<pre contenteditable="true" editable="true">2
5
12
5
378
2015
8</pre>

<p><code>becuri1.out</code></p>

<pre contenteditable="true" editable="true">4</pre>

<h3>Explicație</h3>

<p>Cerința 2.<br>
La minutul <code>0</code> numerele asociate becurilor sunt: <code>12</code>, <code>5</code>, <code>378</code>, <code>2015</code> și <code>8</code>. La minutul <code>1</code> numerele asociate becurilor vor fi: <code>21</code>, <code>5</code>, <code>783</code>, <code>0152</code> și <code>8</code>. La minutul <code>2</code> numerele asociate becurilor vor fi: <code>12</code>, <code>5</code>, <code>837</code>, <code>1520</code> și <code>8</code>. La minutul <code>3</code> numerele asociate becurilor vor fi: <code>21</code>, <code>5</code>, <code>378</code>, <code>5201</code> și <code>8</code>. Numărul maxim de becuri aprinse va fi <code>4</code>, la minutul <code>3</code>.</p>

<h1>Exemplul 3:</h1>

<p><code>becuri1.in</code></p>

<pre contenteditable="true" editable="true">3
5
12
5
378
2015
8</pre>

<p><code>becuri1.out</code></p>

<pre contenteditable="true" editable="true">2</pre>

<h3>Explicație</h3>

<p>Cerința 3.<br>
Al doilea bec este cel care se va fi aprins de cele mai multe ori, deoarece numărul asociat cu cele mai multe cifre ajunge la valoarea inițială abia după <code>4</code> permutări, timp în care becul al doilea va fi aprins de <code>4</code> ori.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;

ifstream cin("becuri1.in");
ofstream cout("becuri1.out");

int cer , n , a[201][201] , maxi;
long long x;

void afiseaza(int n , int p)
{
    int cnt = 0 , c = 0;
    while(n != 0)
    {
        a[p][++cnt] = n % 10;
        n /= 10;
        c++;
    }
    a[p][0] = c;
    maxi = max(maxi , c);
    for(int i = 1 ; i <= cnt / 2 ; i++)
        swap(a[p][i] , a[p][cnt - i + 1]);
}

int prim (int n)
{
    if(n == 0 || n == 1) return 0;
    if(n == 2) return 1;
    if(n % 2 == 0) return 0;
    for(int i = 3 ; i * i <= n ; i += 2)
        if(n % i ==0) return 0;
    return 1;
}

int main()
{
    cin >> cer >> n;
    for(int i = 1 ; i <= n ; i++)
    {
        cin >> x;
        if(x != 0)
        afiseaza(x , i);
    }
    for(int i = 1 ; i <= n ; i++)
        for(int j = 1 ; j <= maxi ; j++)
        {
            if(a[i][0] != 0)
            {
            if(a[i][j] == 0 &amp;&amp; j % a[i][0] == 0) a[i][j] = a[i][a[i][0]];
            else if(a[i][j] == 0 &amp;&amp; j % a[i][0] != 0) a[i][j] = a[i][j % a[i][0]];
            }
        }

    /*for(int i = 1 ; i <= n ; i++)
    {
        for(int j = 1 ; j <= maxi ; j++)
            cout << a[i][j] << " ";
            cout << '\n';
    }*/

    if(cer == 1)
    {
        int rez = 0;
        for(int i = 1 ; i <= n ; i++)
            if(prim(a[i][1])) rez++;

        cout << rez;
    }
    else if(cer == 2)
    {
        int rmax = 0;
        for(int j = 1 ; j <= maxi ; j++)
        {
            int rez = 0;
            for(int i = 1 ; i <= n ; i++)
                if(prim(a[i][j])) rez++;
            if(rez > rmax) rmax= rez;
        }
        cout << rmax;
    }
    else
    {
        int rmax = 0 , ok = 0;
        for(int i = 1 ; i <= n ; i++)
        {
            int rez = 0;
            for(int j = 1 ; j <= n ; j++)
                if(prim(a[i][j])) rez++;
            if(rez > rmax) rmax= rez;
        }
        for(int i = 1 ; i <= n ; i++)
        {
            int rez = 0;
            for(int j = 1 ; j <= n ; j++)
                if(prim(a[i][j])) rez++;
            if(rez == rmax &amp;&amp; rmax != 0) cout << i << " ", ok++;
        }
        if(ok == 0) cout << -1;
    }
}</pre>
