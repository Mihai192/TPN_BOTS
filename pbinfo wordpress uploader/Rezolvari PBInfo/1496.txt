<p>O hartă este codificată printr-o matrice cu <code>N</code> linii și <code>M</code> coloane de elemente numere naturale. Valoarea <code>0</code> semnifică o zonă cu apă. Zonele de uscat sunt codificate prin valori între <code>1</code> și <code>K</code>. Celulele aparținând unei țări <code>I</code> sunt codificate cu valoarea <code>I</code>. Fiecare țară este împărțită în departamente. Prin definiție, un departament reprezintă o mulțime de celule de aceeași valoare, continuă pe linii și coloane (nu și diagonale).</p>

<h1>Cerința</h1>

<p>Fiind dată o hartă codificată ca mai sus. să se determine:</p>

<p>a) Suprafața totală a apei.<br>
b) Lista țărilor cu cele mai multe departamente, ordonată crescător.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>harta1.in</code> conține pe prima linie <code>p</code>. Pentru toate testele de intrare, numărul <code>p</code> poate avea doar valoarea <code>1</code> sau valoarea <code>2</code>. Pe a doua linie conține valorile <code>N</code>, <code>M</code> și <code>K</code> cu semnificația din enunț. Pe următoarele <code>N</code> linii câte <code>M</code> valori, despărțite prin câte un spațiu, reprezentând codificarea hărții.</p>

<h1>Date de ieșire</h1>

<p>Dacă valoarea lui <code>p</code> este <code>1</code>, se va rezolva numai punctul a) din cerință.</p>

<p>În acest caz, în fişierul de ieşire <code>harta1.out</code> se va scrie un singur număr natural n1, reprezentând suprafata totala a apei.</p>

<p>Dacă valoarea lui <code>p</code> este <code>2</code>, se va rezolva numai punctul b) din cerință.</p>

<p>În acest caz, fişierul de ieşire <code>harta1.out</code> va conține pe prima și singura linie valorile ce reprezintă codurile țărilor cu număr maxim de departamente, separate prin câte un spațiu, în ordine crescătoare.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ N , M ≤ 100</code></li>
	<li><code>1 ≤ K ≤ 10</code></li>
	<li>O zonă de uscat poate conține mai multe departamente dintr-o aceeași țară.</li>
	<li>Pentru rezolvarea corectă a cerinței a) se acordă 20% din punctaj, pentru rezolvarea corectă a ambelor cerințe se acordă punctajul maxim.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>harta1.in</code></p>

<pre contenteditable="true" editable="true">1
5 5 3
1 1 2 0 0
3 1 0 2 2
3 0 0 0 2
0 1 3 0 0
0 2 2 1 0</pre>

<p><code>harta1.out</code></p>

<pre contenteditable="true" editable="true">11</pre>

<h3>Explicație</h3>

<p><strong>Se va rezolva numai cerința a)</strong>. Suprafața apei reprezintă numărul de valori de <code>0</code> din matrice.</p>

<h1>Exemplul 2</h1>

<p><code>harta1.in</code></p>

<pre contenteditable="true" editable="true">2
5 5 3
1 1 2 0 0
3 1 0 2 2
3 0 0 0 2
0 1 3 0 0
0 2 2 1 0</pre>

<p><code>harta1.out</code></p>

<pre contenteditable="true" editable="true">1 2</pre>

<h3>Explicație</h3>

<p><strong>Se va rezolva numai cerința b).</strong> Țările cu cele mai multe departamente (<code>3</code> departamente) sunt țările <code>1</code> și <code>2</code>. Se observă că una din zonele de uscat conține <code>2</code> departamente distincte ale țării <code>1</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <algorithm>
using namespace std;

ifstream cin("harta1.in");
ofstream cout("harta1.out");

int n , m ,a[101][101] , b[101][101] , f[11];

int di[]={0 , 0 , -1 , 1};
int dj[]={1 , -1 , 0 , 0};

bool inmat(int x , int y)
{
    return x >= 1 &amp;&amp; x <= n &amp;&amp; y >= 1 &amp; y <= m;
}

int c = 0;

void fill(int x , int y , int val)
{
    a[x][y]=0;
    c++;
    for(int d = 0 ; d < 4 ; ++d)
    {
        int inou = x + di[d];
        int jnou = y + dj[d];
        if(a[inou][jnou]==val &amp;&amp; inmat(inou , jnou))
            fill(inou , jnou , val);
    }
}

int main()
{
    int p , k;
    cin >> p;
    cin >> n >> m >> k;
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= m ; ++j)
            cin >> a[i][j];
    if(p == 1)
    {
        int cnt = 0;
        for(int i = 1 ; i <= n ; ++i)
            for(int j = 1 ; j <= m ; ++j)
                if(a[i][j]==0)
                    cnt ++;
        cout << cnt;
    }
    else
    {
        int max = 0;
        int v[1001] , ind = 0;
        for(int i = 1 ; i <= n ; ++i)
        {
            for(int j = 1 ; j <= m ; ++j)
            {
                int val = a[i][j];
                if(a[i][j]!=0)
                {
                    f[val]++;
                    fill(i , j , a[i][j]);
                    if(f[val] > max)
                        max = f[val];
                }
            }
        }
        for(int i = 1 ; i < 11 ; ++i)
            if(f[i]==max)
                cout << i << ' ';
    }
    return 0;
}</pre>
