<p>Gigel, mare pasionat de jocuri merge cu tatăl său în excursie. Pe drum acesta adoarme și devine personaj principal <br>
într-o cursă de mașini. În visul său este pilot de formula 1 în jocul <strong>Need for Speed</strong>!</p>

<p>Observă că benzina e pe sfârșite! Trebuie să alimenteze urgent de la o benzinărie dar acestea “apar”  numai  când  kilometrajul mașinii este un număr palindromic (citit în ambele sensuri este la fel).</p>

<p>Se uită spre kilometraj și trebuie să decidă repede: merge înainte spre următoarea stație de benzină sau se întoarce spre stația de benzină anterioară. Dacă benzinăriile sunt la distanțe egale, Gigel va merge înainte. Dacă kilometrajul mașinii indică deja un număr palindromic, ratează această benzinărie, nemaiputând opri la timp (are viteză mare) și caută o soluție: altă benzinărie.</p>

<p>Atenție, kilometrajul mașinii în momentul sosirii la benzinărie nu este obligatoriu un număr palindromic (de exemplu, când Gigel se întoarce din drum).</p>

<h1>Cerința</h1>

<p>Presat de timp, Gigel vă roagă să îl ajutați să găsească distanța minimă până la cea mai apropiată benzinărie (numărul palindromic cel mai apropiat) și cât va indica kilometrajul atunci când va sosi la benzinărie.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>benzinarii.in</code> conține o singură valoare <code>n</code> reprezentând kilometrajul mașinii afișat în momentul în care se uită Gigel spre acesta.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>benzinarii.out</code> va conține o singură linie cu două numere,  reprezentând distanța până la cea mai apropiată benzinărie (număr palindromic), respectiv kilometrajul cu care va sosi la benzinărie.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 &lt;= n &lt;= 100.000.000</code></li>
	<li>numerele de pe a doua linie a fișierului de intrare vor fi mai mici decât <code>1.000.000.000</code></li>
</ul>

<h1>Exemplul 1</h1>

<p><code>benzinarii.in</code></p>

<pre contenteditable="true" editable="true">456</pre>

<p><code>benzinarii.out</code></p>

<pre contenteditable="true" editable="true">2 458</pre>

<h3>Explicație</h3>

<p>Cele mai apropiate stații de benzină se găsesc la km: <code>454</code> și <code>464</code>. Distanțele sunt <code>d1=456-454=2</code> și <code>d2=464-456=8</code> deci, este mai convenabil să se întoarcă la km <code>454</code>. Va ajunge când mașina va avea kilometrajul <code>458</code>.</p>

<h1>Exemplul 2</h1>

<p><code>benzinarii.in</code></p>

<pre contenteditable="true" editable="true">1998</pre>

<p><code>benzinarii.out</code></p>

<pre contenteditable="true" editable="true">4 2002</pre>

<h3>Explicație</h3>

<p>Cele mai apropiate stații de benzină se găsesc la km: <code>1991</code> și <code>2002</code>. Este mai convenabil să meargă înainte <code>4</code> Km și va ajunge când mașina va avea kilometrajul <code>2002</code>. (<code>2002=1998+4</code>)</p>

<h1>Exemplul 3</h1>

<p><code>benzinarii.in</code></p>

<pre contenteditable="true" editable="true">4774</pre>

<p><code>benzinarii.out</code></p>

<pre contenteditable="true" editable="true">110 4884</pre>

<h3>Explicație</h3>

<p>Kilometrajul inițial este un număr palindromic dar Gigel nu poate opri la această benzinărie. Cele mai apropiate stații de benzină se găsesc la km: <code>4664</code> și <code>4884</code>. <code>d1=4774-4664=110</code> iar <code>d2=4884-4774=110</code>. Benzinăriile sunt la distanțe egale și Gigel continuă drumul încă <code>110</code> Km până la benzinăria din dreptul numărului <code>4884</code>; kilometrajul va fi <code>4884</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;
ifstream fin("benzinarii.in");
ofstream fout("benzinarii.out");
int pal(int n)
{
    long long ogl = 0 , n1 = n;
    while(n1 != 0)
    {
        ogl = ogl * 10 + n1 % 10;
        n1 /= 10;
    }
    if(ogl == n) return 1;
    else return 0;
}

int main()
{
    long long n , mini = 1000000000 , d1 = 0 , p = 1;
    fin >> n;
    long long n1 = n , n2 = n;
    while(p != 0)
    {
        d1++;
        if(pal(n1+1)) p = 0;
        else n1++;
    }
    if(d1 < mini) mini = d1;
    int d2 = 0 ;
     p = 1;
     while(p != 0)
    {
        d2++;
        if(pal(n-1)) p = 0;
        else n--;
    }
    if(d2 < mini)mini = d2;
    fout << mini << ' ' << mini + 1LL*n2;

    fin.close();
    fout.close();

    return 0;
}</pre>
