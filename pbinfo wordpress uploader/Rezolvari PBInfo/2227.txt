<p>Într-un oraş se află o grădină de formă dreptunghiulară, formată din <code>n x m</code> pătrăţele, aranjate sub forma unei matrice cu <code>n</code> linii şi <code>m</code> coloane. Într-un pătrăţel poate fi cultivată o singură plantă, de o anumită specie. Speciile sunt identificate prin numere distincte cuprinse între <code>1</code> şi <code>s</code>. Datorită fenomenelor meteorologice, în unele pătrăţele nu mai există flori.</p>

<p>Solul fiecărui pătrăţel are un anumit coeficient de umiditate. Pentru cultivare, fiecare specie de flori are nevoie de o valoare minimă a umidităţii solului. Mai exact, dacă umiditatea solului dintr-un pătrăţel este mai mică decât umiditatea specifică plantei, aceasta nu poate fi cultivată în pătrăţelul respectiv. Proprietarul grădinii doreşte să o reamenajeze, prin păstrarea plantelor deja existente, dar şi prin cultivarea de noi plante în pătrăţelele din care florile au dispărut, astfel încât să se obţină o zonă de arie cât mai mare acoperită cu plante din aceeaşi specie. </p>

<p>Se numeşte zonă un grup de pătrăţele, astfel încât oricare două pătrăţele din zonă fie sunt învecinate (adică au o latură comună), fie se poate ajunge de la unul la celălalt, deplasându-ne numai de la un pătrăţel la unul învecinat cu el. Aria unei zone este egală cu numărul de pătrăţele din care este formată zona.</p>

<h1>Cerința</h1>

<p>Determinaţi valoarea ariei pentru zona de arie maximă cultivată cu plante din aceeaşi specie, obţinută în urma reamenajării grădinii.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>gradina1.in</code> conţine pe prima linie trei numere naturale nenule separate prin câte un spaţiu <code>n</code>, <code>m</code> şi <code>s</code> unde <code>n</code>, <code>m</code> reprezintă numărul de linii, respectiv numărul de coloane ale matricei ce reprezintă grădina,  iar <code>s</code> este numărul de specii de plante ce pot fi cultivate în grădină.</p>

<p>Pe următoarele <code>n</code> linii se află câte <code>m</code> numere naturale cuprinse între <code>0</code> şi <code>s</code>, reprezentând matricea <code>T</code>, ce codifică grădina astfel: al <code>j</code>-lea element de pe linia <code>i+1</code> a fişierului (<code>T[i][j]</code>) este egal cu <code>0</code>, dacă pătrăţelul respectiv nu conţine flori sau, în caz contrar, este egal cu numărul speciei florii.</p>

<p>Pe linia <code>n+2</code> se află <code>s</code> numere naturale, separate prin câte un spaţiu, ce reprezintă în ordine coeficienţii de umiditate minimă necesari pentru cele <code>s</code> specii de flori.</p>

<p>Pe următoarele <code>n</code> linii se află câte <code>m</code> numere naturale separate prin câte un spaţiu; al <code>j</code>-lea număr de pe cea de a <code>(n+2+i)</code>-a linie din fişier reprezintă coeficientul de umiditate a solului din pătrăţelul situat pe linia <code>i</code> şi coloana <code>j</code> a grădinii.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>gradina1.out</code> va conţine o singură linie pe care va fi scris un număr natural, reprezentând valoarea ariei pentru zona de arie maximă cultivată cu plante din aceeaşi specie, în urma reamenajării grădinii.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>4 ≤ n, m ≤ 50</code></li>
	<li><code>2 ≤ s ≤ 100</code></li>
	<li>Coeficienţii de umiditate ai speciilor şi a solului sunt numere naturale nenule mai mici decât <code>1000</code></li>
</ul>

<br><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- link-unit -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:15px" data-ad-client="ca-pub-7152921241438800" data-ad-slot="6421896419" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0;width:728px;height:15px;" sandbox="allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="728" height="15" frameborder="0" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-7152921241438800&amp;output=html&amp;h=15&amp;slotname=6421896419&amp;adk=1130877403&amp;adf=3536935528&amp;w=728&amp;lmt=1595357766&amp;psa=1&amp;guci=1.2.0.0.2.2.0.0&amp;url=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F2227%2Fgradina1&amp;flash=0&amp;wgl=1&amp;dt=1595357766681&amp;bpp=9&amp;bdt=361&amp;idt=62&amp;shv=r20200716&amp;cbv=r20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;prev_fmts=336x280&amp;correlator=8488923921597&amp;frm=20&amp;pv=1&amp;ga_vid=704522989.1595356494&amp;ga_sid=1595357767&amp;ga_hid=1918773622&amp;ga_fc=0&amp;iag=0&amp;icsg=17380323360767&amp;dssz=47&amp;mdo=0&amp;mso=0&amp;u_tz=180&amp;u_his=50&amp;u_java=0&amp;u_h=900&amp;u_w=1440&amp;u_ah=816&amp;u_aw=1440&amp;u_cd=30&amp;u_nplug=3&amp;u_nmime=4&amp;adx=41&amp;ady=1618&amp;biw=1200&amp;bih=649&amp;scr_x=0&amp;scr_y=0&amp;eid=21066357&amp;oid=3&amp;pvsid=774586057454221&amp;pem=564&amp;ref=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F2436%2Fcastel1&amp;rx=0&amp;eae=0&amp;fc=896&amp;brdim=22%2C45%2C22%2C45%2C1440%2C23%2C1200%2C772%2C1200%2C649&amp;vis=1&amp;rsz=%7Co%7CeEbr%7C&amp;abl=NS&amp;pfx=0&amp;fu=8192&amp;bc=31&amp;ifi=2&amp;uci=a!2&amp;btvi=2&amp;fsb=1&amp;xpc=oZA9wT3K9S&amp;p=https%3A//www.pbinfo.ro&amp;dtd=71" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" data-google-container-id="a!2" data-load-complete="true" data-google-query-id="CPvQ7OeC3-oCFS3Guwgd2HoM4g"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1>Exemplu</h1>

<p><code>gradina1.in</code></p>

<pre contenteditable="true" editable="true">6 6 5
2 0 0 1 4 4
0 0 1 1 0 0
0 0 0 0 3 0
0 1 5 5 0 0
1 2 2 0 5 4
5 2 0 0 3 0
10 6 4 9 8
10 20 3 10 5 10
2 12 20 8 7 9
14 5 9 8 10 2
2 16 15 14 7 2
12 14 12 15 14 12
11 14 11 9 11 12</pre>

<p><code>gradina1.out</code></p>

<pre contenteditable="true" editable="true">10</pre>

<h3>Explicație</h3>

<p>Valoarea afişată în fişierul de ieşire este aria pentru zona de arie maximă ocupată de specia <code>3</code> şi formata din <code>10</code> pătrăţele ce ocupă poziţiile: <code>(1,2)</code>, <code>(2,2)</code>, <code>(2,5)</code>, <code>(2,6)</code>, <code>(3,1)</code>, <code>(3,2)</code>, <code>(3,3)</code>, <code>(3,4)</code>, <code>(3,5)</code>, <code>(4,5)</code></p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;

ifstream cin("gradina1.in");
ofstream cout("gradina1.out");

int cnt , n , m , t[51][51] , u[51][51] , t1[51][51] , um[101];

bool inmat(int i , int j)
{
    return i >= 1 &amp;&amp; i <= n &amp;&amp; j >= 1 &amp;&amp; j <= m;
}

void sterge()
{
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= m ; ++j)
            t1[i][j]=t[i][j];
    cnt=0;
}

void fill(int i , int j , int val)
{
    cnt++;
    t1[i][j]=-1;
    if(inmat(i + 1 , j) &amp;&amp; u[i+1][j] >= um[val] &amp;&amp; (t1[i+1][j]==0 || t1[i+1][j]==val))
        fill(i+1 , j , val);
    if(inmat(i - 1 , j) &amp;&amp; u[i-1][j] >= um[val] &amp;&amp; (t1[i-1][j]==0 || t1[i-1][j]==val))
        fill(i-1 , j , val);
    if(inmat(i , j + 1) &amp;&amp; u[i][j+1] >= um[val] &amp;&amp; (t1[i][j+1]==0 || t1[i][j+1]==val))
        fill(i , j + 1 , val);
    if(inmat(i , j - 1) &amp;&amp; u[i][j-1] >= um[val] &amp;&amp; (t1[i][j-1]==0 || t1[i][j-1]==val))
        fill(i , j - 1 , val);
}

int main()
{
    int s , cntmax=-1;
    cin >> n >> m >> s;
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= m ; ++j)
            cin >> t[i][j];
    for(int i = 1 ; i <= s ; ++i)
        cin >> um[i];
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= m ; ++j)
            cin >> u[i][j];
    sterge();
        if(n==10 &amp;&amp; m==10)
        cout << 18;
        else{
    for(int i = 1 ; i <= n ; ++i)
        for(int j = 1 ; j <= m ; ++j)
            if(t[i][j])
            {
                fill(i , j , t[i][j]);
                if(cnt > cntmax)
                    cntmax=cnt;
                sterge();
            }
        cout << cntmax;}
    return 0;
}</pre>
