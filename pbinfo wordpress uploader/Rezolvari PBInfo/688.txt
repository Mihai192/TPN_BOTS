<p>Pixy locuieşte într-o ţară colorată. Harta ţării poate fi reprezentată sub forma unui dreptunghi împărţit în celule, organizate în <code>M</code> linii şi <code>N</code> coloane. Liniile sunt numerotate de la <code>1</code> la <code>M</code>, începând de la linia de sus, iar coloanele sunt numerotate de la <code>1</code> la <code>N</code> începând de la coloana din stânga. Fiecare celulă are o anumită culoare. Culorile sunt codificate cu literele <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code> (există doar <code>6</code> culori).</p>

<p>Casa lui Pixy se găseşte în celula de coordinate <code>(1,1)</code>, iar prietena lui, Pixela, locuieşte în celula de coordonate <code>(M,N)</code>. Pixy doreşte să ajungă la aleasa inimii sale, însă nu poate păşi decât pe celule de aceeaşi culoare. Ştim că Pixy se poate deplasa doar orizontal, sau vertical cu câte o căsuţă la fiecare pas.</p>

<p>Pentru a putea ajunge la Pixela, Pixy va proceda astfel: alege o culoare şi va recolora celula în care se găseşte casa sa cu culoarea aleasă. Astfel va obţine o zonă de celule adiacente având toate aceeaşi culoare. Două celule se consideră adiacente dacă se învecinează orizontal sau vertical. De exemplu, pentru harta din figura 1, dacă alege culoarea având codul <code>D</code> va obţine zona marcată din figura 2, toate celulele din această zonă având culoarea <code>D</code>. </p>

<p><img alt="" height="217" src="/resurse/probleme/651-700/pixy.png" width="715"></p>

<p>În continuare Pixy va proceda asemănător: alege o nouă culoare, şi recolorează toată zona obţinută la pasul anterior cu noua culoare, astfel zona pe care poate păşi se lărgeşte. De exemplu, dacă în situaţia din figura 2, Pixy alege acum culoarea cu codul <code>C</code> va obţine situaţia din figura 3. </p>

<p>Procedeul continuă până când celula corespunzătoare casei Pixelei face şi ea parte din zona obţinută de Pixy în urma recolorărilor.</p>

<p>Alegerea culorilor de la fiecare pas trebuie făcută cu mare grijă, astfel încât numărul de recolorări să fie minim.</p>

<p>Acum lui Pixy îi mai rămâne sarcina de a găsi un drum cât mai scurt pe care îl va parcurge până la Pixela, păşind doar pe celulele din zona obţinută în urma recolorărilor succesive, adică celulele de pe parcursul drumului vor avea toate aceeaşi culoare. </p>

<h1>Cerința</h1>

<p>Se cere să determinaţi:</p>

<p>a) numărul minim de recolorări <br>
b) lungimea drumului minim de la Pixy la Pixela, parcurs pe zona obţinută în urma recolorărilor de la cerinţa a).</p>

<h1>Date de intrare</h1>

<p>Fişierul de intrare <code>pixy.in</code> conţine pe prima linie două numere naturale <code>M</code> şi <code>N</code>, separate printr-un spaţiu, reprezentând dimensiunile hărţii. Următoarele <code>M</code> linii conţin câte <code>N</code> litere mari ale alfabetului englez reprezentând culorile celulelor de pe hartă.</p>

<h1>Date de ieșire</h1>

<p>p. Prima linie a fişierului <code>pixy.out</code> va conţine un număr întreg reprezentând numărul minim de recolorări.</p>

<p>A doua linie a fişierului conţine o singură valoare întreagă, reprezentând lungimea drumului parcurs de Pixy.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>2≤M,N≤500</code></li>
	<li>Pentru răspuns corect la prima cerinţă se acordă <code>40%</code> din punctaj, pentru răspuns corect la cea de a doua cerinţă se acordă <code>60%</code> din punctaj.</li>
	<li>Celulele vecine cu casa lui Pixy au iniţial culori diferite de culoarea casei.</li>
</ul>

<br><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- link-unit -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:15px" data-ad-client="ca-pub-7152921241438800" data-ad-slot="6421896419" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0;width:728px;height:15px;" sandbox="allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="728" height="15" frameborder="0" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-7152921241438800&amp;output=html&amp;h=15&amp;slotname=6421896419&amp;adk=1130877403&amp;adf=872686288&amp;w=728&amp;lmt=1595356502&amp;psa=1&amp;guci=1.2.0.0.2.2.0.0&amp;url=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F688%2Fpixy&amp;flash=0&amp;wgl=1&amp;adsid=NT&amp;dt=1595356502627&amp;bpp=5&amp;bdt=582&amp;idt=222&amp;shv=r20200716&amp;cbv=r20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;prev_fmts=336x280&amp;correlator=2302107512179&amp;frm=20&amp;pv=1&amp;ga_vid=704522989.1595356494&amp;ga_sid=1595356503&amp;ga_hid=344278587&amp;ga_fc=0&amp;iag=0&amp;icsg=17380323360767&amp;dssz=47&amp;mdo=0&amp;mso=0&amp;u_tz=180&amp;u_his=4&amp;u_java=0&amp;u_h=900&amp;u_w=1440&amp;u_ah=816&amp;u_aw=1440&amp;u_cd=30&amp;u_nplug=3&amp;u_nmime=4&amp;adx=41&amp;ady=1919&amp;biw=1200&amp;bih=649&amp;scr_x=0&amp;scr_y=0&amp;eid=21066357&amp;oid=3&amp;pvsid=1439073216272160&amp;pem=564&amp;ref=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F700%2Flabir&amp;rx=0&amp;eae=0&amp;fc=896&amp;brdim=22%2C45%2C22%2C45%2C1440%2C23%2C1200%2C772%2C1200%2C649&amp;vis=1&amp;rsz=%7Co%7CeEbr%7C&amp;abl=NS&amp;pfx=0&amp;fu=8192&amp;bc=31&amp;ifi=2&amp;uci=a!2&amp;btvi=2&amp;fsb=1&amp;xpc=q6DzhIL2Bd&amp;p=https%3A//www.pbinfo.ro&amp;dtd=231" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" data-google-container-id="a!2" data-load-complete="true" data-google-query-id="CPHglI3-3uoCFbjGuwgdZ4MKog"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1>Exemplu</h1>

<p><code>pixy.in</code></p>

<pre contenteditable="true" editable="true">5 6
ADDBCD
DCDCBE
ACBAED
CBDADE
ABDCEE</pre>

<p><code>pixy.out</code></p>

<pre contenteditable="true" editable="true">5
9</pre>

<h1>Explicație</h1>

<p>Se fac următoarele recolorări:</p>

<p><strong>Pasul 1</strong>: se alege culoarea <code>D</code>:</p>

<p><img alt="" height="132" src="/resurse/probleme/651-700/pixy-1.png" width="93"></p>

<p><strong>Pasul 2</strong>: se alege culoarea <code>C</code>:</p>

<p><img alt="" height="134" src="/resurse/probleme/651-700/pixy-2.png" width="91"></p>

<p><strong>Pasul 3</strong>: se alege culoarea <code>A</code>:</p>

<p><img alt="" height="131" src="/resurse/probleme/651-700/pixy-3.png" width="95"></p>

<p><strong>Pasul 4</strong>: se alege culoarea <code>D</code>:</p>

<p><img alt="" height="127" src="/resurse/probleme/651-700/pixy-4.png" width="90"></p>

<p><strong>Pasul 5</strong>: se alege culoarea <code>E</code>:</p>

<p><img alt="" height="143" src="/resurse/probleme/651-700/pixy-5.png" width="97"></p>

<p>S-au făcut deci <code>5</code> recolorări. Drumul pe care îl poate parcurge Pixy este următorul: <code>(1,1) → (1,2) → (1,3) → (2,3) → (2,4) → (3,4) → (4,4) → (4,5) → (5,5) → (5,6)</code> şi are lungimea <code>9</code>.</p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <queue>
using namespace std;

ifstream cin("pixy.in");
ofstream cout("pixy.out");

const int di[] = {0 , 0 , -1 , 1};
const int dj[] = {-1 , 1 , 0 , 0};
int n , m , a[501][501] , b[501][501] , c[501][501];

char s;

struct poz
{
    int i , j;
};

queue <poz> q;

int inside(int i , int j)
{
    return i >= 1 &amp;&amp; i <= n &amp;&amp; j >= 1 &amp;&amp; j <= m;
}


void lee()
{
    poz r;
    r.i = 1 , r.j = 1;
    q.push(r);
    b[r.i][r.j] = 1;
    c[r.i][r.j] = 1;
    while(!q.empty())
    {
        poz r;
        r = q.front();
        for(int i = 0 ; i < 4 ; i++)
        {
            int inou = r.i + di[i];
            int jnou = r.j + dj[i];
            if(inside(inou , jnou))
            {
                if(a[inou][jnou] == a[r.i][r.j])
                {
                    if(b[inou][jnou] == 0)
                    {
                        c[inou][jnou] = c[r.i][r.j];
                        b[inou][jnou] = b[r.i][r.j] + 1;
                        q.push({inou , jnou});
                    }
                    else if(c[inou][jnou] > c[r.i][r.j])
                    {
                        c[inou][jnou] = c[r.i][r.j];
                        b[inou][jnou] = b[r.i][r.j] + 1;
                        q.push({inou , jnou});
                    }
                    else if(c[inou][jnou] == c[r.i][r.j] &amp;&amp; b[inou][jnou] > b[r.i][r.j] + 1)
                    {
                        b[inou][jnou] = b[r.i][r.j] + 1;
                        q.push({inou , jnou});
                    }
                }

                else if(c[inou][jnou] > c[r.i][r.j]+1)
                {
                    c[inou][jnou] = c[r.i][r.j] + 1;
                    b[inou][jnou] = b[r.i][r.j] + 1;
                    q.push({inou , jnou});
                }
                else if(c[inou][jnou] == c[r.i][r.j]+1 &amp;&amp; b[inou][jnou] > b[r.i][r.j] + 1)
                {
                    b[inou][jnou] = b[r.i][r.j] + 1;
                    q.push({inou , jnou});
                }
            }
        }
        q.pop();
    }
}
int verif(int cod , int x)
{
    return (cod &amp;(1<<x))!=0;
}

int nr1(int n)
{
    int c = 0;
    while(n != 0)
    {
        c += n % 2;
        n /= 2;
    }
    return c;
}
int main()
{
    cin >> n >> m;
    for(int i = 1 ; i <= n ; i++)
        for(int j = 1 ; j <= m ; j++)
        {
            cin >> s;
            a[i][j] = s - 'A';
            c[i][j] = 1000000000;
        }

    lee();
    /*for(int i = 1 ; i <= n ; i++)
    {
        for(int j = 1 ; j <= m ; j++)
            cout << b[i][j] << " ";
        cout << '\n';
    }
    cout << '\n';
    for(int i = 1 ; i <= n ; i++)
    {
        for(int j = 1 ; j <= m ; j++)
            cout << c[i][j] << " ";
        cout << '\n';
    }*/
    cout << c[n][m] - 1 << '\n' << b[n][m] - 1;
}</pre>
