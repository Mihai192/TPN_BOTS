<p>Un număr natural nenul <code>m</code> se numește <strong>norocos</strong> dacă pătratul lui se poate scrie ca sumă de <code>m</code> numere naturale consecutive. Un număr natural <code>m</code> se numește <strong>k-norocos</strong>, dacă este egal cu produsul a exact <code>k</code> numere prime distincte. Observați că între cele două proprietăți definite nu există nicio legătură.</p>

<h1>Cerința</h1>

<p>Dându-se <code>k</code> și <code>N</code> numere naturale, scrieți un program care să determine:  </p>

<p>a) Cel mai mic și cel mai mare număr norocos dintre cele <code>N</code> numere citite<br>
b) Câte numere <strong>k-norocoase</strong> sunt în șirul de N numere citite</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>norocos.in</code> conține pe prima linie un număr natural <code>C</code>. Pentru toate testele de intrare, numărul <code>C</code> are una din valorile <code>1</code> sau <code>2</code>. Pe linia a doua a fișierului se găsesc numerele naturale <code>N</code> și <code>k</code>, cu semnificația din enunț, iar pe a treia linie se găsesc <code>N</code> numere naturale, separate prin câte un spațiu.</p>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire este <code>norocos.out</code>.</p>

<p>Dacă <code>C=1</code>, se va rezolva numai punctul a). În acest caz, în fişierul de ieşire se vor scrie, separate printr-un spațiu, în această ordine, cel mai mic și cel mai mare număr norocos dintre cele <code>N</code> numere citite. Dacă nu există niciun număr norocos se va afișa valoarea <code>0</code>. Dacă există un singur număr norocos, acesta se va afișa de două ori.</p>

<p>Dacă <code>C=2</code>, se va rezolva numai punctul b). În acest caz, în fişierul de ieşire se va scrie un singur număr reprezentând numărul de numere <strong>k-norocoase</strong> citite.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>1 ≤ N ≤ 1000</code></li>
	<li><code>2 ≤ k ≤ 30</code></li>
	<li><code>1 ≤</code> numerele citite de pe a treia linie a fișierului <code>≤ 2 000 000 000</code></li>
	<li>Pentru rezolvarea corectă a primei cerinţe se acordă 40 de puncte, pentru rezolvarea corectă a celei de-a doua cerințe se acordă 60 de puncte.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>norocos.in</code></p>

<pre contenteditable="true" editable="true">1
9 3
165 12 33 30 5 18 105 15 4</pre>

<p><code>norocos.out</code></p>

<pre contenteditable="true" editable="true">5 165</pre>

<h3>Explicație</h3>

<p>Atenție, <code>C=1</code>, deci se va rezolva doar prima cerință.</p>

<p>Cel mai mic număr norocos este <code>5</code><br>
<code>5</code><sup><code>2</code></sup><code>=25=3+4+5+6+7</code></p>

<p>Cel mai mare număr norocos este <code>165</code><br>
<code>165</code><sup><code>2</code></sup><code>=27225=83+84+85+…+246+247</code><br>
Observați faptul că, deși se citește valoarea lui <code>k</code>, aceasta nu este folosită în rezolvarea cerinței 1.</p>

<h1>Exemplul 2</h1>

<p><code>norocos.in</code></p>

<pre contenteditable="true" editable="true">2
5 3
165 31 165 105 44</pre>

<p><code>norocos.out</code></p>

<pre contenteditable="true" editable="true">3</pre>

<h3>Explicație</h3>

<p>Atenție, <code>C=2</code>, deci se va rezolva doar a doua cerință.</p>

<p>Cele trei numere k-norocoase sunt <code>165</code>, <code>165</code>, <code>105</code></p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
using namespace std;
ifstream cin("norocos.in");
ofstream cout("norocos.out");
int knorocoase(int n)
{
    int d = 2 , cnt = 0;
    while(n > 1)
    {
        int p = 0;
        while(n % d == 0) p++ , n /= d;
        if(p == 1) cnt++;
        else if(p > 1) return 0;
        d++;
        if(d *d  > n) d = n;
    }
    return cnt;
}

int main()
{
    int cer , n , k , x , min = 2000000001 , max = -2000000001 , cnt = 0;
    cin >> cer >> n >> k;
    if(cer == 1)
    {
        for(int i = 1 ; i <= n ; i++)
        {
            cin >> x;
            if(x % 2 == 1)
            {
                if(x < min) min = x;
                if(x > max) max = x;
            }
        }
        if(min != 2000000001 &amp;&amp; max != -2000000001)
            cout << min << " " << max;
        else cout << 0;
    }
    else
    {
       for(int i = 1 ; i <= n ; i++)
        {
            cin >> x;
            if(knorocoase(x) == k) cnt++;
        }
        cout << cnt;
    }

}</pre>
