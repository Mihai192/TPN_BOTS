<p><img align="right" alt="" src="/resurse/9dc152/p-1100/traseu1.png"> Într-un oraș există un hotel de formă cubică, cu <code>N</code> etaje, numerotate de la <code>1</code> la <code>N</code>. Suprafața fiecărui etaj <code>K</code> (<code>1 ≤ K ≤ N</code>) este pătratică și este împărțită în <code>N x N</code> camere identice alăturate, dispuse pe <code>N</code> linii și <code>N</code> coloane, fiecare cameră având drept etichetă un triplet de numere naturale (<code>K L C</code>) (<code>K=</code>etajul, <code>L=</code>linia, <code>C=</code>coloana, <code>1 ≤ L, C ≤ N</code>), ca în imaginea alăturată. </p>

<p><img align="left" alt="" src="/resurse/9dc152/p-1100/traseu2.png"> Dintre cele <code>N x N x N</code> camere ale hotelului, una este specială deoarece în ea locuiește de mult timp un șoricel. Fiind isteț, el știe eticheta camerei în care se află precum și eticheta camerei în care bucătarul hotelului depozitează alimente. </p>

<p>Studiind  hotelul, șoricelul a constatat că pe fiecare etaj, din orice cameră poate intra în toate camerele care au un perete comun cu aceasta (existând un mic orificiu pentru aerisire). </p>

<p><img align="left" alt="" src="/resurse/9dc152/p-1100/traseu3.png"> De asemenea, șoricelul a constatat că din fiecare cameră (situată la etajele <code>2</code>, <code>3</code>, …, sau <code>N-1</code>) poate intra în camera situată imediat deasupra ei și în camera situată imediat sub ea.</p>

<p>Fiind un șoricel binecrescut, el nu intră în nicio cameră ocupată de clienți ca să nu-i deranjeze. Hotelul având mulți clienți, șoricelul trebuie să-și găsească cel mai scurt traseu de la camera lui la camera cu alimente, traseu care să treacă printr-un număr minim de camere, toate neocupate. </p>

<h1>Cerinţe: </h1>

<p>Se cere să se determine:<br>
a) numărul de camere prin care trece cel mai scurt traseu al șoricelului de la camera lui la camera cu alimente (inclusiv camera lui şi camera cu alimente);<br>
b) etichetele camerelor prin care trece traseul determinat la punctul a).</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>traseu.in</code> conține:</p>

<ul>
	<li>pe prima linie, două numere naturale <code>N</code> și <code>M</code> separate printr-un spațiu, <code>N</code> cu semnificația din enunț iar <code>M</code> reprezentând numărul de camere ocupate de clienţii hotelului;<br>
pe a doua linie, trei numere naturale <code>K1 L1 C1</code>, separate prin câte un spațiu, reprezentând eticheta camerei în care se află șoricelul;</li>
	<li>pe a treia linie, trei numere naturale  <code>K2 L2 C2</code>, separate prin câte un spațiu, reprezentând eticheta camerei în care sunt depozitate alimentele;</li>
	<li>pe fiecare dintre următoarele <code>M</code> linii, câte trei numere naturale <code>X Y Z</code>, separate prin câte un spaţiu, reprezentând etichetele celor <code>M</code> camere ocupate de clienți.</li>
</ul>

<h1>Date de ieșire</h1>

<p>Fișierul de ieșire <code>traseu.out</code> va conține pe prima linie un număr natural <code>T</code> reprezentând numărul de camere prin care trece cel mai scurt traseu al șoricelului de la camera lui la camera cu alimente determinat la punctul a). Pe fiecare din următoarele <code>T</code> linii, se vor scrie câte trei numere naturale <code>X Y Z</code>, separate prin câte un spaţiu, reprezentând etichetele camerelor prin care trece traseul determinat la punctul a), în ordinea în care sunt parcurse camerele de către șoricel pentru a ajunge din camera lui în camera cu alimente. </p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>2 ≤ N ≤ 100</code>; <code>1 ≤ M ≤ 5000</code>&nbsp;și <code>M &lt; N*N-2</code></li>
	<li>Șoricelul nu intră decât în camere neocupate de clienți.</li>
	<li>Camera șoricelului este o cameră neocupată de clienți.</li>
	<li>Dacă există mai multe trasee ale șoricelului de la camera lui la camera de alimente care trec prin exact <code>T</code> camere, atunci traseul afișat va fi cel mai mic traseu din punct de vedere lexicografic.</li>
	<li>Eticheta  <code>(X1 Y1 Z1)</code> se consideră strict mai mică în sens lexicografic ca eticheta <code>(X2 Y2 Z2)</code> dacă este satisfăcută doar una dintre condițiile:
	<ol>
		<li><code>X1&nbsp;&lt; X2</code></li>
		<li><code>X1 = X2</code> și <code>Y1 &lt; Y2</code></li>
		<li><code>X1 = X2</code> și <code>Y1 = Y2</code> și <code>Z1 &lt; Z2</code></li>
	</ol></li>
	<li>Eticheta  <code>X1 Y1 Z1</code> se consideră egală cu eticheta <code>X2 Y2 Z2</code> dacă <code>X1 = X2</code> și <code>Y1 = Y2</code> și <code>Z1 = Z2</code>. Vom scrie egalitatea lor astfel: <code>(X1 Y1 Z1) = (X2 Y2 Z2)</code>.</li>
	<li>Traseul ce trece (în această ordine) prin camerele cu etichetele <code>(X1 Y1 Z1)</code>, <code>(X2 Y2 Z2)</code>,…, <code>(XT YT ZT)</code> este mai mic din punct de vedere lexicografic ca traseul <code>(A1 B1 C1)</code>, <code>(A2 B2 C2)</code>,…, <code>(AT BT CT)</code> dacă există un indice <code>J</code> (<code>1≤J≤T</code>) astfel încât <code>(X1 Y1 Z1) = (A1 B1 C1)</code>, <code>(X2 Y2 Z2) = (A2 B2 C2)</code>…., <code>(XJ-1 YJ-1 ZJ-1) = (AJ-1 BJ-1 CJ-1)</code> iar eticheta <code>(XJ YJ ZJ)</code> este strict mai mică ca eticheta <code>(AJ BJ CJ)</code>.</li>
	<li>Se acordă: 40% din punctaj pentru determinarea corectă a numărului <code>T</code>&nbsp;și 100% din punctaj pentru rezolvarea corectă a ambelor cerințe.</li>
	<li>Se garantează că există soluție pentru ambele cerințe, pentru toate datele de test.</li>
</ul>

<br><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- link-unit -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:15px" data-ad-client="ca-pub-7152921241438800" data-ad-slot="6421896419" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:15px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent;"><iframe id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0;width:728px;height:15px;" sandbox="allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="728" height="15" frameborder="0" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-7152921241438800&amp;output=html&amp;h=15&amp;slotname=6421896419&amp;adk=1130877403&amp;adf=872686288&amp;w=728&amp;lmt=1595356525&amp;psa=1&amp;guci=1.2.0.0.2.2.0.0&amp;url=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F1108%2Ftraseu&amp;flash=0&amp;wgl=1&amp;dt=1595356525278&amp;bpp=24&amp;bdt=532&amp;idt=204&amp;shv=r20200716&amp;cbv=r20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;prev_fmts=336x280%2C0x0&amp;nras=1&amp;correlator=7299170970138&amp;frm=20&amp;pv=1&amp;ga_vid=704522989.1595356494&amp;ga_sid=1595356525&amp;ga_hid=553579975&amp;ga_fc=0&amp;iag=0&amp;icsg=17380323360767&amp;dssz=47&amp;mdo=0&amp;mso=0&amp;u_tz=180&amp;u_his=8&amp;u_java=0&amp;u_h=900&amp;u_w=1440&amp;u_ah=816&amp;u_aw=1440&amp;u_cd=30&amp;u_nplug=3&amp;u_nmime=4&amp;adx=41&amp;ady=2080&amp;biw=1200&amp;bih=649&amp;scr_x=0&amp;scr_y=0&amp;oid=3&amp;pvsid=3257987003425539&amp;pem=564&amp;ref=https%3A%2F%2Fwww.pbinfo.ro%2Fprobleme%2F2167%2Falee&amp;rx=0&amp;eae=0&amp;fc=896&amp;brdim=22%2C45%2C22%2C45%2C1440%2C23%2C1200%2C772%2C1200%2C649&amp;vis=1&amp;rsz=%7Co%7CeEbr%7C&amp;abl=NS&amp;pfx=0&amp;fu=8192&amp;bc=31&amp;ifi=2&amp;uci=a!2&amp;btvi=1&amp;fsb=1&amp;xpc=IXymIFxCmV&amp;p=https%3A//www.pbinfo.ro&amp;dtd=213" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" data-google-container-id="a!2" data-load-complete="true" data-google-query-id="CLKI_Zf-3uoCFROdsgodeW4B_Q"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script><h1>Exemplu</h1>

<p><code>traseu.in</code></p>

<pre contenteditable="true" editable="true">3 4
1 1 1
3 3 3
3 3 1
2 1 1
3 1 1
3 1 3</pre>

<p><code>traseu.out</code></p>

<pre contenteditable="true" editable="true">7
1 1 1
1 1 2
1 1 3
1 2 3
1 3 3
2 3 3
3 3 3</pre>

<h1>Explicație</h1>

<p><img align="right" alt="" src="/resurse/9dc152/p-1100/traseu4.png"> Hotelul are trei etaje (<code>1</code>, <code>2</code> şi <code>3</code>). Pe fiecare etaj sunt <code>3*3</code> camere. Șoricelul se află în camera cu eticheta <code>(1 1 1)</code> iar camera cu alimente are eticheta <code>(3 3 3)</code>.</p>

<p>Sunt <code>4</code> camere ocupate de clienţi. Acestea au etichetele&nbsp;: <code>3 3 1</code>, <code>2 1 1</code>, <code>3 1 1</code>, <code>3 1 3</code>.<br>
Traseul cel mai scurt trece prin <code>T=7</code> camere. Sunt mai multe astfel de trasee. De exemplu:</p>

<ol>
	<li><code>(1 1 1, 1 1 2, 1 1 3, 1 2 3, 1 3 3, 2 3 3, 3 3 3)</code></li>
	<li><code>(1 1 1, 1 1 2, 1 1 3, 2 1 3, 2 2 3, 3 2 3, 3 3 3)</code></li>
	<li><code>(1 1 1, 1 2 1, 1 3 1, 1 3 2, 2 3 2, 3 2 3, 3 3 3)</code></li>
	<li>etc.</li>
</ol>

<p>Cel mai mic astfel de traseu (în sens lexicografic) este traseul 1). </p>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <cstring>
#include <queue>
using namespace std;
ifstream cin("traseu.in");
ofstream cout("traseu.out");

int di[] = {-1 ,  0 ,  0 , 0 , 0 , 1};
int dj[] = { 0 , -1 ,  0 , 0 , 1 , 0};
int dk[] = { 0 ,  0 , -1 , 1 , 0 , 0};
struct poz
{
    int i , j , k;
};
int a[101][101][101] , n , m;
poz p1 , p2 , dr[1000001];
queue <poz> Q;

bool inside(int i , int j , int k)
{
    return i >= 1 &amp;&amp; i <= n &amp;&amp; j >= 1 &amp;&amp; j <= n &amp;&amp; k >= 1 &amp;&amp; k <= n;
}
void lee(poz p)
{
    Q.push(p);
    a[p.i][p.j][p.k] = 1;
    while(! Q.empty())
    {
        p = Q.front();
        for(int d = 0 ; d < 6 ; d++)
        {
            int inou = p.i + di[d];
            int jnou = p.j + dj[d];
            int knou = p.k + dk[d];
            if(inside(inou , jnou , knou) &amp;&amp; a[inou][jnou][knou] == 0)
            {
                poz pnou;
                pnou.i = inou;
                pnou.j = jnou;
                pnou.k = knou;
                Q.push(pnou);
                a[inou][jnou][knou] = a[p.i][p.j][p.k] + 1;
            }

        }
        Q.pop();

    }
}
int main()
{
    cin >> n >> m;
    cin >> p1.i >> p1.j >> p1.k >> p2.i >> p2.j >> p2.k;
    for(int i = 1 ; i <= m ; i++)
    {
        int x , y , z;
        cin >> x >> y >> z;
        a[x][y][z] = -1;
    }
    lee(p1);
    cout << a[p2.i][p2.j][p2.k] << '\n';
    int l = 1;
    dr[1] = p2;
    int i , j , k;
    i = p2.i , j = p2.j , k = p2.k;
    while(i != p1.i || j != p1.j || k != p1.k)
    {
        for(int d = 0 ; d < 6 ; d++)
        {
            int inou = i + di[d];
            int jnou = j + dj[d];
            int knou = k + dk[d];
            if(a[inou][jnou][knou] == a[i][j][k] - 1)
            {
                l++;
                dr[l].i = inou;
                dr[l].j = jnou;
                dr[l].k = knou;
                i = inou;
                j = jnou;
                k = knou;
                break;
            }
        }
    }
    for(int i = l ; i >= 1 ; i--)
    {
        cout << dr[i].i << " " << dr[i].j << " " << dr[i].k << '\n';
    }
}</pre>
