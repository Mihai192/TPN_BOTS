<p>Se consideră o mulțime <code>S</code> care conține <code>N</code> șiruri de caractere formate din litere mici ale alfabetului englezesc.</p>

<p>Un șir de caractere se numește <strong>interesant</strong> în raport cu celelalte șiruri ale mulțimii, dacă nu există un alt șir în mulțime care să-l conțină ca subșir. De exemplu, dacă mulțimea <code>S</code> conține șirurile <code>abc</code>, <code>bde</code> și <code>abcdef</code>, atunci singurul șir interesant este <code>abcdef</code> deoarece <code>abc</code> și <code>bde</code> nu îl conțin ca subșir. Mai mult, <code>abc</code> și <code>bde</code> sunt subșiruri în <code>abcdef</code>, deci nu sunt interesante.</p>

<h1>Cerința</h1>

<p>Fiind dată o mulțime <code>S</code> formată din <code>N</code> șiruri de caractere se cere:</p>

<ol>
	<li>Să se determine cel mai lung șir. Dacă sunt mai multe șiruri având aceeași lungime maximă, se cere cel mai mic din punct de vedere lexicografic.</li>
	<li>Să se determine toate șirurile interesante din  mulțimea <code>S</code>.</li>
</ol>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>interesant.in</code> conține pe prima linie două numere naturale <code>p</code> și <code>N</code>, despărțite prin spațiu. Pentru toate testele de intrare, numărul <code>p</code> poate avea doar valoarea <code>1</code> sau valoarea <code>2</code>. Pe următoarele <code>N</code> linii, se găsesc șirurile de caractere, câte unul pe linie.</p>

<h1>Date de ieșire</h1>

<p>Dacă valoarea lui <code>p</code> este <code>1</code>,  se va rezolva numai cerința 1.  <br>
În acest caz, în fișierul de ieșire <code>interesant.out</code> se va scrie cel mai lung șir dintre cele citite. Dacă există mai multe șiruri de aceeași lungime, se va scrie cel mai mic din punct de vedere lexicografic.   <br>
Dacă valoarea lui <code>p</code> este <code>2</code>, se va rezolva numai cerința 2.  <br>
În acest caz, fișierul de ieșire <code>interesant.out</code> va conține pe prima linie o valoare <code>K</code> ce reprezintă numărul de șiruri interesante, iar pe următoarele <code>K</code> linii, șirurile interesante în ordinea în care apar în fișierul de intrare.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>2 ≤ N ≤ 200</code></li>
	<li>Lungimea unui șir va fi cuprinsă între <code>1</code> și  <code>5000</code></li>
	<li>Un subșir al șirului de caractere <code>C</code><sub><code>0</code></sub><code>C</code><sub><code>1</code></sub><code>C</code><sub><code>2</code></sub><code> …C</code><sub><code>k</code></sub> se definește ca fiind o succesiune de caractere <code>C</code><sub><code>i1</code></sub><code>C</code><sub><code>i2</code></sub><code>C</code><sub><code>i3</code></sub><code>…C</code><sub><code>ik</code></sub>, unde <code>0 ≤ i1 &lt; i2 &lt; i3 &lt; … &lt; ik ≤ k</code>.</li>
	<li>Fișierul de intrare NU conține șiruri identice.</li>
	<li>Pentru rezolvarea corectă a primei cerințe se acordă 20 de puncte, iar pentru cerința a doua se acordă 80 de puncte.</li>
</ul>

<h1>Exemplul 1</h1>

<p><code>interesant.in</code></p>

<pre contenteditable="true" editable="true">1 5
abcacaaz
ad
abcacaad
acd
zyt</pre>

<p><code>interesant.out</code></p>

<pre contenteditable="true" editable="true">abcacaad</pre>

<h3>Explicație</h3>

<p><code>p=1</code><br>
Fișierul de intrare conține <code>5</code> șiruri.<br>
<code>abcacaad</code> este șirul de lungime maximă. Șirul <code>abcacaaz</code> are aceeași lungime, dar este mai mare din punct de vedere lexicografic.</p>

<ul>
	<li>Atenție! Pentru acest test se rezolvă doar cerința 1.*</li>
</ul>

<h1>Exemplul 2</h1>

<p><code>interesant.in</code></p>

<pre contenteditable="true" editable="true">2 5
abcacaad
ad
zayyt
acd
zyt</pre>

<p><code>interesant.out</code></p>

<pre contenteditable="true" editable="true">2
abcacaad
zayyt</pre>

<h3>Explicație</h3>

<p><code>p=2</code><br>
Fișierul de intrare conține <code>5</code> șiruri.<br>
<code>ad</code>, <code>acd</code> sunt subșiruri al lui <code>abcacaad</code>, iar <code>zyt</code> este subșir al lui <code>zayyt</code></p>

<ul>
	<li>Atenție! Pentru acest test se rezolvă doar cerința 2.*</li>
</ul>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <cstring>
using namespace std;

ifstream cin("interesant.in");
ofstream cout("interesant.out");

char m[201][5001];

bool subsir(char a[] , char b[])
{
    if(strlen(a) > strlen(b))
        return 0;
    else
    {
        int i = 0;
        for(int j = 0 ; b[j] ; ++j)
        {
            if(a[i]==b[j])
                i++;
            else if(strlen(a) - i > strlen(b) - j)
                    return 0;
        }
        if(i == strlen(a))
            return 1;
        return 0;
    }
}

int main()
{
    int t , n;
    cin >> t >> n;
    for(int i = 1 ; i <= n ; ++i)
        cin >> m[i];
    if(t==1)
    {
        int max=0;
        int ind;
        for(int i = 1 ; i <= n ; ++i)
        {
            if(strlen(m[i]) > max)
                max=strlen(m[i]) , ind = i;
            else if(strlen(m[i])==max)
                if(strcmp(m[ind] , m[i]) > 0)
                    ind=i;
        }
        cout << m[ind];
    }
    else
    {
        int vec[1001], p = 0;
        for(int i = 1 ; i <= n ; ++i)
        {
            bool ok = 1;
            for(int j = 1 ; j <= n ; ++j)
            {
                if(j != i &amp;&amp; subsir(m[i] , m[j]))
                {
                    ok=0;
                }
            }
            if(ok)
                vec[++p]=i;
        }
        cout << p << endl;
        for(int i = 1 ; i <= p ; ++i)
            cout << m[vec[i]] << endl;
    }
    return 0;
}</pre>
