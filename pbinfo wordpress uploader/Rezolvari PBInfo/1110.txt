<p>Spionul 008 vrea să găsească o locație secretă în junglă, având asupra lui un dispozitiv de localizare. Iniţial spionul se află la intrarea în junglă pe nivelul <code>1</code> şi cu fiecare pas, el avansează de la nivelul <code>i</code> la nivelul <code>i+1</code>, ajungând la locaţia secretă, aflată pe ultimul nivel, în poziţia <code>u</code> faţă de marginea stângă a nivelului curent. Pentru a ajunge în locaţia secretă, el poate să se deplaseze cu o poziţie spre Sud-Est (codificat cu caracterul <code>E</code>) sau spre Sud-Vest (codificat cu caracterul <code>V</code>), trecând de pe nivelul <code>i</code> pe nivelul <code>i+1</code> cu viteză constantă. Numărul de poziţii de pe un nivel creşte cu unu faţă de nivelul anterior, conform imaginii alăturate. Numim traseu o succesiune formată din caracterele <code>E</code> sau <code>V</code>, corespunzătoare deplasării spionului de pe nivelul <code>1</code> la locaţia secretă. Pentru exemplul din figura alăturată succesiunea de caractere <code>VEEVE</code> reprezintă un traseu ce corespunde locaţiei secrete din poziţia <code>4</code> a nivelului <code>6</code>.</p>

<p><img align="right" alt="" src="/resurse/9dc152/p-1100/spion1.png"></p>


<h1>Cerinţă</h1>

<p>Cunoscând succesiunea de caractere corespunzătoare unui traseu, determinaţi:<br>
a) poziţia locației secrete de pe ultimul nivel; <br>
b) numărul de trasee distincte pe care le poate urma spionul plecând din poziţia inițială pentru a ajunge în locaţia secretă corespunzătoare traseului dat. Două trasee se consideră distincte dacă diferă prin cel puţin o poziţie.</p>

<h1>Date de intrare</h1>

<p>Fișierul de intrare <code>spion1.in</code> conține pe prima linie un număr natural <code>p</code>din <code>{1,2}</code>, iar pe a doua linie o succesiune de caractere corespunzătoare unui traseu.</p>

<h1>Date de ieșire</h1>

<p>Dacă valoarea lui <code>p</code> este <code>1</code>, atunci se va rezolva numai punctul a) din cerință. În acest caz, fişierul de ieşire <code>spion1.out</code> va conţine pe prima linie un număr natural ce reprezintă poziția de pe nivelul final a locației secrete.</p>

<p>Dacă valoarea lui <code>p</code> este <code>2</code>, atunci se va rezolva numai punctul b) din cerință. În acest caz, fişierul de ieşire <code>spion1.out</code> va conţine pe prima linie un număr natural ce reprezintă numărul de trasee distincte modulo <code>100 003</code>.</p>

<h1>Restricții și precizări</h1>

<ul>
	<li><code>2 ≤</code> lungimea şirului paşilor <code>≤ 100 000</code>;</li>
	<li>pentru 20% din teste valoarea lui <code>p=1</code>;</li>
	<li>pentru alte 10% din teste valoarea lui <code>p=2</code> şi lungimea secvenţei de caractere <code>≤ 255</code>;</li>
	<li>pentru alte 10% din teste valoarea lui <code>p=2</code> şi <code>300 ≤</code> lungimea secvenţei de caractere <code>≤ 1900</code>;</li>
	<li>pentru alte 10% din teste valoarea lui <code>p=2</code> şi <code>3000 ≤</code> lungimea secvenţei de caractere <code>≤ 5000</code>.</li>
</ul>

<table class="table table-condensed table-bordered"><tbody><tr><td>
h1. Exemplul 1

<p><code>spion1.in</code></p>

<pre contenteditable="true" editable="true">1
VEEVE</pre>

<p><code>spion1.out</code></p>

<pre contenteditable="true" editable="true">4</pre>

<h1>Explicație</h1>

<p>Locația secretă este în poziţia <code>4</code> de pe nivelul <code>6</code>.</p>

<p></p></td><td><p></p>

<h1>Exemplul 2</h1>

<p><code>spion1.in</code></p>

<pre contenteditable="true" editable="true">2
VEV</pre>

<p><code>spion1.out</code></p>

<pre contenteditable="true" editable="true">3</pre>

<h1>Explicație</h1>

<p>Există trei trasee: <code>VVE</code>, <code>VEV</code>, <code>EVV</code>.</p>

<p></p></td><td><p></p>

<h1>Exemplul 3</h1>

<p><code>spion1.in</code></p>

<pre contenteditable="true" editable="true">2
EVEVVEVEEE</pre>

<p><code>spion1.out</code></p>

<pre contenteditable="true" editable="true">210</pre>

</td></tr></tbody></table>						
<pre class="EnlighterJSRAW" data-enlighter-language="cpp">#include <fstream>
#include <cstring>
using namespace std;

ifstream cin("spion1.in");
ofstream cout("spion1.out");

#define mod 100003

int E[1000001];
int C[100001];

void ciur(int E[] , int n)
{
    for(int i = 2 ; i <= n ; i++) E[i] = 1;
    for(int i = 2 ; i * i <= n ; i++)
        if(E[i] == 1)
            for(int j = i*i ; j <= n ; j += i) E[j] = 0;

}

int np(int n , int x)
{
    ///la ce putere apare x in n faactorial
    int p = x , val = 0;
    while(n >= p)
    {
        val += n / p;
        p *= x;
    }
    return val;
}

unsigned long long xlan(int x , int n)
{
    if(n == 0) return 1;
    else
    {
        unsigned long long p = xlan(x , n / 2);
        if(n % 2 == 0) p = p * p % mod;
        else p = p * p * x % mod;
        return p;
    }
}
int main()
{
    int cer;
    char s[100001];
    ciur(E , 100001);
    cin >> cer >> s;
    int i = 0 , cnt = 0 , n = strlen(s);
    while(s[i] != '\0')
    {
        if(s[i] == 'E') cnt++;
        i++;
    }
    if(cer == 1) cout << cnt + 1;
    else
    {
        unsigned long long k = 1;
        for(int i = 2 ; i <= n ; i++)
            if(E[i]) C[i] = np(n , i);
        for(int i = 2 ; i <= cnt ; i++)
            if(E[i]) C[i] -= np(cnt , i);
        for(int i = 2 ; i <= n - cnt ; i++)
            if(E[i]) C[i] -= np(n - cnt , i);
        for(int i = 2 ; i <= n; i++)
            k = k * xlan(i , C[i]) % mod;
        cout << k;
    }

}</pre>
